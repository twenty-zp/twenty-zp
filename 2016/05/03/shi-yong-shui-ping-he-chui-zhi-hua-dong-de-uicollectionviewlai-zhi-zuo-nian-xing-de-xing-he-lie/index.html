<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [译]使用水平和垂直滑动的UICollectionView来制作粘性的行和列 · Twenty's 时间念</title><meta name="description" content="[译]使用水平和垂直滑动的UICollectionView来制作粘性的行和列 - Twenty's 时间念"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon1.png"><link rel="stylesheet" href="/css/apollo.css"><script src="/baiduAnalyse.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://blog.img421.com/atom.xml" title="Twenty's 时间念"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/twenty-zp" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><script type="text/javascript" src="/ad.js"></script><div class="post"><article class="post-block"><h1 class="post-title">[译]使用水平和垂直滑动的UICollectionView来制作粘性的行和列</h1><div class="post-info">May 3, 2016</div><div class="post-content"><h4 id="一个tableView可以被水平和垂直滑动吗"><a href="#一个tableView可以被水平和垂直滑动吗" class="headerlink" title="一个tableView可以被水平和垂直滑动吗?"></a>一个tableView可以被水平和垂直滑动吗?</h4><blockquote>
<p>免责申明（必读！）：本博客提供的所有教程的翻译原稿均来自于互联网，仅供学习交流之用，切勿进行商业传播。同时，转载时不要移除本申明。如产生任何纠纷，均与本博客所有人、发表该翻译稿之人无任何关系。谢谢合作！</p>
</blockquote>
<p>应用程序日常开发工作的现实之一就是克服日常的挑战.<a href="http://www.brightec.co.uk/ideas/uicollectionview-using-horizontal-and-vertical-scrolling-sticky-rows-and-columns?destination=taxonomy/term/1" target="_blank" rel="external">原文</a></p>
<p>远非是我们要抱怨它。我们喜欢每一个新的障碍并且爱解决各种各样的困惑和难题为我们的客户服务。</p>
<p>我们最近的挑战就是用一个<code>tableView</code>来实现水平和垂直的滑动。条件是：当水平滑动时第一列和垂直滑动时的第一行要保持静止.</p>
<p>最后,我们需要给这个tableView包含一个巨大的数据,因此它重要性就是能够平稳的滑动。<br><img src="http://ocar0timh.bkt.clouddn.com/1083C35C-F832-472A-9E10-6E687A60A425318204-d52b7b752f79a9e0.gif" alt=""></p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>首先,我们简单说明下挑战–有时在开发的第一步就是要明确实际的问题是什么:</p>
<ul>
<li>创建一个水平和垂直滑动的tableView.</li>
<li>水平滑动第一列和垂直滑动第一行的粘性.</li>
<li>使用大数据的情况下,必须要保持平滑的滚动.</li>
</ul>
<h2 id="第一次尝试-UITableView"><a href="#第一次尝试-UITableView" class="headerlink" title="第一次尝试-UITableView"></a>第一次尝试-UITableView</h2><p>我们开始考虑在UIScrollView中包含一个<code>UITableView</code>,但经过一些尝试,我们意识到:定制它的滚动和粘性是一个棘手的任务。</p>
<p>使用UITableView来做出必要的定制工作,真的很痛苦.因此,我们决定使用可定制的UICollectionView.</p>
<h2 id="第二次尝试-UICollectionView"><a href="#第二次尝试-UICollectionView" class="headerlink" title="第二次尝试-UICollectionView"></a>第二次尝试-UICollectionView</h2><p><code>UICollectionView</code>提供了强大的定制化服务,允许你设置一个自定义的<code>UICollectionFlowLayout</code>.不幸的是,网格布局的滚动只能沿着一个轴滑动:要么是水平要么是垂直.</p>
<p>我们希望我们能嵌入一个UIScrollView的集合,允许我们能够两个方向都能滑动,因此多方考虑我们决定使用<code>UICollectionFlowLayout</code>的父类<code>UICollectionViewLayout</code>的子类。</p>
<h2 id="UICollectionViewLayout子类"><a href="#UICollectionViewLayout子类" class="headerlink" title="UICollectionViewLayout子类"></a>UICollectionViewLayout子类</h2><p>以下是创建<code>collectionView</code> 的步骤:</p>
<ol>
<li>创建一个<code>UICollectionViewLayout</code>的子类<code>CustomCollectionViewLayout</code>.</li>
<li>在<code>storyboard</code>中拖动一个<code>UICollectionView</code>.我们也可以使用代码创建，这取决于你自己.</li>
<li><p>在<code>storyboard</code>中的<code>Attributes Inspector</code>设置一些属性.我们设置<code>Layout</code>为<code>Custom</code>,设置<code>Class</code>为<code>CustomCollectionViewLayout</code>.<code>Scrolling Enabled</code>为选中状态,如果我们想要每次只滑动一个方向,选中<code>Direction Lock Enabled</code>.否则,会同一时刻滑动两个方向.</p>
<p><img src="http://ocar0timh.bkt.clouddn.com/98830D28-8BD4-4430-A7D7-6A8AE082298E.png" alt=""></p>
</li>
<li>最后,将<code>UICollectionView</code>连接到<code>UIViewController</code>.不要忘记连接<code>dataSource</code>和<code>delegate</code>.</li>
<li>在我们的<code>CollectionView</code>中,这个视图表示<code>row</code>和<code>列所在的row</code>,因此记住<code>sections</code>的索引下标和<code>item</code>的索引下标.这取决我们设置<code>collectionView flow layout</code>的方向.<br><img src="http://ocar0timh.bkt.clouddn.com/1795C81F-30AD-4C5F-94A6-C969C76B93C6.png" alt=""></li>
</ol>
<ol>
<li><p>一旦完成了设置<code>collectionView</code>的方式,我们就需要设置我们自己所要创建的<code>custom collection view layout</code>.首先,我们要设置3个管理所有数据的属性.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) NSMutableArray *itemAttributes;</div><div class="line">@property (nonatomic,strong) NSMutableArray *itemsSize;</div><div class="line">@property (nonatomic, assign) CGSize contentSize;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你要自定义<code>item</code>的大小,你需要定义以下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGSize)sizeForItemWithColumnIndex:(NSUInteger)columnIndex;</div></pre></td></tr></table></figure>
<p>我强烈推荐你计算item大小存储到<code>itemsSize</code>中,是为了每一个列只计算一次.提高性能.</p>
</li>
<li><p>写如下方法并返回<code>YES</code>,是为了调用当你每次滑动<code>CollectionView</code>的时候都能够调用<code>prepareLayout</code>方法.你必须设置这个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds</div><div class="line">&#123;  </div><div class="line">return YES; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>你需要调用以下方法布局显示的items</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">            *  CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩	形。</div><div class="line">            *  CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新	矩形。</div><div class="line">            *  CGRectIntegral: 返回包围源矩形的最小整数矩形。</div><div class="line">            *  const CGRect CGRectZero: 一个原点在(0, 0)，且长宽均为 	0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等	价的。</div><div class="line">            *  const CGRect CGRectNull: 空矩形。这个会在，比如说，求两	个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。</div><div class="line">            *  const CGRect CGRectInfinite: 无穷大矩形。</div><div class="line">            *  CGRectDivide: 将源矩形分为两个子矩形。</div><div class="line">            */</div><div class="line">         - (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</div><div class="line">                 &#123;</div><div class="line">             NSMutableArray *attributes = [@[] mutableCopy];</div><div class="line">              for (NSArray *section in self.itemAttributes) &#123;</div><div class="line">                     [attributes addObjectsFromArray:[section filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(UICollectionViewLayoutAttributes *evaluatedObject, NSDictionary *bindings) &#123;</div><div class="line">                 return CGRectIntersectsRect(rect, [evaluatedObject frame]);</div><div class="line">              &#125;]]];</div><div class="line">            &#125;</div><div class="line">                  return attributes;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>你需要根据<code>indexPath</code>返回<code>layout attributes</code>,如果才能返回出正确的<code>item attribute</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    return      self.itemAttributes[indexPath.section]  [indexPath.row];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>你还需要返回<code>collectionView</code>内容视图的滑动大小.</p>
<pre><code>- (CGSize)collectionViewContentSize
{
        return self.contentSize;
}
</code></pre></li>
<li><p>最后,需要设<code>prepareLayout</code>方法.我们重画<code>collectionView</code>这将要被每次调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)prepareLayout;</div></pre></td></tr></table></figure>
</li>
<li><p>最后,我们要确定要展示的数据,否则返回<code>void</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ([self.collectionView numberOfSections] == 0) </div><div class="line">&#123;</div><div class="line">       return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>现在必须检查我们是否已经计算了<code>item</code>的attribute.在确定的情况下,我们将要使用这个attributes来粘性头部(第15步).否则,我们要每一次都计算,并且保存他们到<code>itemAttributes</code>数组中.</p>
<p>基本上,我们为了保证它们可见,是通过遍历所有的<code>items</code>然后计算<code>item</code>的<code>size</code>、<code>frame</code>和<code>zIndex</code>.</p>
<p>最后,我们使用<code>last item</code>来计算<code>contentSize</code>为了计算出content的全部高度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> 	 // 以下代码只在prepareLayout中执行一次</div><div class="line">   self.itemAttributes = [@[] mutableCopy];</div><div class="line">   self.itemsSize = [@[] mutableCopy];</div><div class="line">// Tip:我们可以使用NSUInteger来代替numberOfItemsInSection</div><div class="line">  // NSUInteger numberOfItems = [self.collectionView numberOfItemsInSection:section];</div><div class="line">  //计算每一列中item 的大小</div><div class="line">  if (self.itemsSize.count != NUMBEROFCOLUMNS) &#123;</div><div class="line">    [self calculateItemsSize];</div><div class="line">  &#125;</div><div class="line">  // 通过循环计算items</div><div class="line">    for (int section = 0; section &lt; [self.collectionView numberOfSections]; section++) &#123;</div><div class="line">    NSMutableArray *sectionAttributes = [@[] mutableCopy];</div><div class="line">    for (NSUInteger index = 0; index &lt; NUMBEROFCOLUMNS; index++) &#123;</div><div class="line">        CGSize itemSize = [self.itemsSize[index] CGSizeValue];</div><div class="line">        // 每一次都创建一个UICollectionViewLayoutAttributes,并且保存到数组中</div><div class="line">        NSIndexPath *indexPath = [NSIndexPath indexPathForItem:index inSection:section];</div><div class="line">        UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];</div><div class="line">        attributes.frame = CGRectIntegral(CGRectMake(xOffset, yOffset, itemSize.width, itemSize.height));</div><div class="line">               if (section == 0 &amp;&amp; index == 0) &#123;</div><div class="line">            attributes.zIndex = 1024; //设置(Sec0Row0)的第一项,使其能在第一列和第一行之上</div><div class="line">        &#125; else if (section == 0 || index == 0) &#123;</div><div class="line">            attributes.zIndex = 1023; //设置第一列和第一行在其余为设置的item之上</div><div class="line">        &#125;</div><div class="line">        if (section == 0) &#123;</div><div class="line">            CGRect frame = attributes.frame;</div><div class="line">            frame.origin.y = self.collectionView.contentOffset.y;</div><div class="line">            attributes.frame = frame; // 顶部(第一行)黏性</div><div class="line">        &#125;</div><div class="line">        if (index == 0) &#123;</div><div class="line">            CGRect frame = attributes.frame;</div><div class="line">            frame.origin.x = self.collectionView.contentOffset.x;</div><div class="line">            attributes.frame = frame; // 左部(第一列)黏性</div><div class="line">        &#125;</div><div class="line">        [sectionAttributes addObject:attributes];</div><div class="line">        xOffset = xOffset+itemSize.width;</div><div class="line">        column++;</div><div class="line">        // 如果最后的列,定义最终的宽度</div><div class="line">        if (column == NUMBEROFCOLUMNS) &#123;</div><div class="line">            if (xOffset &gt; contentWidth) &#123;</div><div class="line">                contentWidth = xOffset;</div><div class="line">            &#125;  </div><div class="line">            // Reset values</div><div class="line">            column = 0;</div><div class="line">            xOffset = 0;</div><div class="line">            yOffset += itemSize.height;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    [self.itemAttributes addObject:sectionAttributes];</div><div class="line">  &#125;</div><div class="line">   //获取最后的一个item 来计算 content的全部高度</div><div class="line">  UICollectionViewLayoutAttributes *attributes = [[self.itemAttributes lastObject] lastObject];</div><div class="line">  contentHeight = attributes.frame.origin.y+attributes.frame.size.height;</div><div class="line">  self.contentSize = CGSizeMake(contentWidth, contentHeight);</div></pre></td></tr></table></figure>
</li>
<li><p>事实上我们已经在之前计算过<code>items attributes</code>,我们只需要(垂直滑动的时候)通过设置<code>first row</code>的<code>y-offset</code>和(水平滑动)设置<code>first columns</code>的<code>x-offset</code>即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//如果不进入以下if语句,就会执行计算方法</div><div class="line">    if (self.itemAttributes.count &gt; 0) &#123;</div><div class="line">            for (int section = 0; section &lt; [self.collectionView numberOfSections]; section++) &#123;</div><div class="line">               NSUInteger numberOfItems = [self.collectionView numberOfItemsInSection:section];</div><div class="line">               for (NSUInteger index = 0; index &lt; numberOfItems; index++) &#123;</div><div class="line">                    if (section != 0 &amp;&amp; index != 0)      &#123;         //这是我们不需要黏性的内容</div><div class="line">                   continue;</div><div class="line">                  &#125;</div><div class="line">               UICollectionViewLayoutAttributes *attributes = </div><div class="line">               [self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:index inSection:section]];</div><div class="line">               if (section == 0) &#123; // 顶部(第一行)黏性</div><div class="line">                   CGRect frame = attributes.frame;</div><div class="line">                   frame.origin.y = self.collectionView.contentOffset.y;</div><div class="line">                   attributes.frame = frame;</div><div class="line">               &#125;</div><div class="line">               if (index == 0) &#123; // 左部(第一列)黏性</div><div class="line">                   CGRect frame = attributes.frame;</div><div class="line">                   frame.origin.x = self.collectionView.contentOffset.x;</div><div class="line">                   attributes.frame = frame;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/twenty-zp/CustomCollectionViewLayout/archive/master.zip" target="_blank" rel="external">源代码下载</a></p>
<p><a href="http://blog.img421.com/2016/05/03/shi-yong-shui-ping-he-chui-zhi-hua-dong-de-uicollectionviewlai-zhi-zuo-nian-xing-de-xing-he-lie/">ps: 转载注明出处</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/02/itunes-store-xie-yi-shui-wu-he-yin-xing-ye-wu-2016zui-xin-ban/" class="prev">PREV</a><a href="/2016/04/14/react-native-ru-men/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://blog.img421.com">Twenty's 时间念</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>