<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twenty&#39;s 时间念</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.img421.com/"/>
  <updated>2017-01-12T09:35:54.000Z</updated>
  <id>http://blog.img421.com/</id>
  
  <author>
    <name>Twenty&#39;s 时间念</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序没你想象的那么难</title>
    <link href="http://blog.img421.com/2017/01/11/wx-xiaochengxu-mei-ni-xiangxiang-de-nan/"/>
    <id>http://blog.img421.com/2017/01/11/wx-xiaochengxu-mei-ni-xiangxiang-de-nan/</id>
    <published>2017-01-11T02:03:30.000Z</published>
    <updated>2017-01-12T09:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里做一下这两天的小程序记录。</p>
<p>有时间再做一下开发流程。</p>
<p><a href="https://github.com/twenty-zp/todayNews.git" target="_blank" rel="external">代码链接</a></p>
<h4 id="1月12日-公司让做一个项目-后台的接口只是还未完成-因此只是简单的写了一些假数据做布局-同时完善仿今日头条小程序的详情内容页面"><a href="#1月12日-公司让做一个项目-后台的接口只是还未完成-因此只是简单的写了一些假数据做布局-同时完善仿今日头条小程序的详情内容页面" class="headerlink" title="1月12日,公司让做一个项目,后台的接口只是还未完成.因此只是简单的写了一些假数据做布局.同时完善仿今日头条小程序的详情内容页面."></a>1月12日,公司让做一个项目,后台的接口只是还未完成.因此只是简单的写了一些假数据做布局.同时完善仿今日头条小程序的详情内容页面.</h4><hr>
<h4 id="1月11日-通过群内的分享，今日头条-决定仿写一个简单的今日头条-当日完成列表的开发-并且通过查看文档，小程序并不支持html-所以想起iOS-html替换文本内容，显示自定义的html页面-有了html-解析逻辑"><a href="#1月11日-通过群内的分享，今日头条-决定仿写一个简单的今日头条-当日完成列表的开发-并且通过查看文档，小程序并不支持html-所以想起iOS-html替换文本内容，显示自定义的html页面-有了html-解析逻辑" class="headerlink" title="1月11日,通过群内的分享，今日头条,决定仿写一个简单的今日头条,当日完成列表的开发,并且通过查看文档，小程序并不支持html,所以想起iOS html替换文本内容，显示自定义的html页面,有了html 解析逻辑;"></a>1月11日,通过群内的分享，今日头条,决定仿写一个简单的今日头条,当日完成列表的开发,并且通过查看文档，小程序并不支持html,所以想起iOS html替换文本内容，显示自定义的html页面,有了html 解析逻辑;</h4><hr>
<h4 id="1月9日-简单的开发了豆瓣的电影列表"><a href="#1月9日-简单的开发了豆瓣的电影列表" class="headerlink" title="1月9日,简单的开发了豆瓣的电影列表"></a>1月9日,简单的开发了豆瓣的电影列表</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里做一下这两天的小程序记录。&lt;/p&gt;
&lt;p&gt;有时间再做一下开发流程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/twenty-zp/todayNews.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码链接&lt;/a&gt;&lt;/
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://blog.img421.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins非root用户使用sudo等本地环境变量</title>
    <link href="http://blog.img421.com/2016/11/29/jenkins-noroot-yonghu-use-sudo/"/>
    <id>http://blog.img421.com/2016/11/29/jenkins-noroot-yonghu-use-sudo/</id>
    <published>2016-11-29T07:40:06.000Z</published>
    <updated>2016-11-29T08:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在使用<code>Jenkins</code>持续集成过程中,因为项目使用的是<code>Ionic</code>进行开发,在提交到<code>svn</code>时,进行打包查看<code>html</code>、<code>js</code>等文件,并没有更新成功,此是因为更新成功后并没有进行<code>ionic build</code>.</p>
</blockquote>
<h3 id="1-添加Jenkins脚本"><a href="#1-添加Jenkins脚本" class="headerlink" title="1.添加Jenkins脚本"></a>1.添加Jenkins脚本</h3><p>选择<code>增加构建步骤</code>-&gt;<code>Execute shell</code>脚本.<br><img src="http://ocar0timh.bkt.clouddn.com/57F55E4C-A212-4B9B-850B-DDD780E3878B.png" alt=""><br>在命令行中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ionic build ios</div></pre></td></tr></table></figure>
<p><img src="http://ocar0timh.bkt.clouddn.com/22BE8882-1C79-4968-A3BF-0FA0301D9DEA.png" alt=""><br>然后进行保存. </p>
<p>当点击<code>立即重新构建</code>后,<code>Jenkins</code>会报<code>Finished: FAILURE</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo: no tty present and no askpass program specified</div></pre></td></tr></table></figure>
<p><img src="http://ocar0timh.bkt.clouddn.com/C4490F76-90D5-4729-A2F5-12E10ADA1E4B.png" alt=""><br>因为此用户为非root用户,并且要输入一个切换root用户的密码.</p>
<h3 id="2-修改sudo不输入密码"><a href="#2-修改sudo不输入密码" class="headerlink" title="2.修改sudo不输入密码"></a>2.修改sudo不输入密码</h3><p>在终端进行输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo visudo</div></pre></td></tr></table></figure>
<p>输入电脑用户密码.在<code>## Same thing without a password</code>下输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jenkins ALL=(ALL) NOPASSWD: ALL</div></pre></td></tr></table></figure>
<p><img src="http://ocar0timh.bkt.clouddn.com/626C39EB-6BE9-4C0C-B474-4159EB9F7C19.png" alt=""><br>jenkins: 为你的jenkins系统的用户名,可以在<code>电脑的活动监视器的用户中查看</code>.</p>
<p>重新点击<code>立即重新构建</code>后,<code>Jenkins</code>会报<code>Finished: FAILURE</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ionic command not found</div></pre></td></tr></table></figure>
<p>因为<code>ionic</code>,只是在MAC本地安装,因此给<code>Jenkins</code>添加环境变量.</p>
<h3 id="3-Jenkins添加环境变量"><a href="#3-Jenkins添加环境变量" class="headerlink" title="3.Jenkins添加环境变量"></a>3.Jenkins添加环境变量</h3><ol>
<li>打开终端,输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div></pre></td></tr></table></figure>
</li>
</ol>
<p>将输出的内容,进行copy(拷贝).</p>
<ol>
<li>打开 系统管理-&gt;系统设置-&gt;全局属性-&gt;Environment variables 通过增加键值对列表,键为<code>PATH</code>,值为<code>拷贝的输出内容</code>:<br><img src="http://ocar0timh.bkt.clouddn.com/2C84B794-4953-4A81-96B4-AECCFEB40BF3.png" alt=""></li>
</ol>
<h3 id="4-完成"><a href="#4-完成" class="headerlink" title="4.完成"></a>4.完成</h3><p>再次点击<code>立即重新构建</code>,项目会从<code>svn</code>进行更新,并且通过<code>sudo ionic build ios</code>进行编译,最后在进行打包完成,并上传到<a href="http://fir.im" target="_blank" rel="external">fir服务器</a><br><img src="http://ocar0timh.bkt.clouddn.com/D1720569-F315-49B0-B728-86D6E3DA8211.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用&lt;code&gt;Jenkins&lt;/code&gt;持续集成过程中,因为项目使用的是&lt;code&gt;Ionic&lt;/code&gt;进行开发,在提交到&lt;code&gt;svn&lt;/code&gt;时,进行打包查看&lt;code&gt;html&lt;/code&gt;、&lt;code&gt;js&lt;/code&gt;等
    
    </summary>
    
    
      <category term="ionic系列" scheme="http://blog.img421.com/tags/ionic%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用Jenkins构建Cordova,解决fatal error: ‘Cordova/xxx.h’ file not found</title>
    <link href="http://blog.img421.com/2016/11/23/iOS-shiyong-Jenkins-goujian-Cordova/"/>
    <id>http://blog.img421.com/2016/11/23/iOS-shiyong-Jenkins-goujian-Cordova/</id>
    <published>2016-11-23T02:30:30.000Z</published>
    <updated>2016-11-23T06:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.img421.com/2016/11/23/iOS-shiyong-Jenkins-goujian-Cordova/">博客地址</a><br>此项目并没有使用<strong>fastlane</strong>脚本来集成打包环境,又因为<strong>fastlane</strong>命令因为测试环境和正式环境发布到不同的地址,如果并未用文档记录下来的话,时间长久会使运营＋测试人员遗忘,所以使用<strong>Jenkins</strong>图型化界面让运营和测试人员清晰的在局域网内自己来进行控制打包.</p>
<p>在使用<strong>Jenkins</strong>,因为头一次将<strong>Cordova</strong>进行集成打包,所以在构建的过程中,遇到</p>
<blockquote>
<p>fatal error: ‘Cordova/CDV.h’ file not found </p>
<p> #import <cordova cdv.h=""></cordova></p>
<p> BUILD FAILED </p>
</blockquote>
<p>此种编译失败错误.</p>
<p>通过在网上<strong>Google</strong>查找,在<a href="http://stackoverflow.com/questions/12184767/phonegap-cdvviewcontroller-h-file-not-found-when-archiving-for-ios" target="_blank" rel="external">Stack Overflow</a>找到解决办法,如下图:<br><img src="http://ocar0timh.bkt.clouddn.com/8E985126-9FF7-4E7C-B2EE-7BF6C5D4E50C.png" alt=""><br><strong>但是因为此解决方法因时间长久,而网上多是类似的解决答案</strong>,因此对于我来说一直没有解决.</p>
<p>但是此中日志报错既然是找不到头文件,那么就在日志文件中搜索<strong>Cordova</strong>关键字,找出打包编译时所查询的目录路径.<br><img src="http://ocar0timh.bkt.clouddn.com/3989B17F-2879-4911-A509-60F03B6DDE2B.png" alt=""><br>可以看到查询头文件的路径.<br>因此,以上在之前的<strong>Header Search Path</strong>方法中添加路径不能使用.<br>将以上的路劲修改以下内容即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(SRCROOT)/CordovaLib/build/$(CONFIGURATION)-$&#123;PLATFORM_NAME&#125;/include</div></pre></td></tr></table></figure>
<p>再次编译得到如下成功<br><img src="http://ocar0timh.bkt.clouddn.com/FA3171F4-62D5-42A8-ACA8-47F0DF98ECAA.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.img421.com/2016/11/23/iOS-shiyong-Jenkins-goujian-Cordova/&quot;&gt;博客地址&lt;/a&gt;&lt;br&gt;此项目并没有使用&lt;strong&gt;fastlane&lt;/strong&gt;脚本来集成打包环境,又
    
    </summary>
    
    
      <category term="ionic系列" scheme="http://blog.img421.com/tags/ionic%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法8-成对交换节点</title>
    <link href="http://blog.img421.com/2016/11/18/chengdui-jiaohuan-jiedian/"/>
    <id>http://blog.img421.com/2016/11/18/chengdui-jiaohuan-jiedian/</id>
    <published>2016-11-18T02:58:00.000Z</published>
    <updated>2016-11-18T03:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,</p>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<p>给定一个链表,交换每两个相邻的节点,并返回它的头节点。</p>
<p>例:<br>链表：1-&gt;2-&gt;3-&gt;4，你能得到2-&gt;1-&gt;4-&gt;3链表.</p>
<p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ListNode &#123;</div><div class="line">    var val: Int</div><div class="line">    var next: ListNode?</div><div class="line">    init(_ val: Int,next: ListNode?) &#123;</div><div class="line">        self.val = val</div><div class="line">        self.next = next</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">class Solution &#123; </div><div class="line">    //输出链表</div><div class="line">    func showList(head: ListNode)  &#123;</div><div class="line">        var printStr: String =  &quot;&quot;</div><div class="line">        var first = head.next</div><div class="line">        while (first != nil) &#123;</div><div class="line">            if  first!.next != nil &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.val)-&gt;&quot;)</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.val)&quot;)</div><div class="line">            &#125;</div><div class="line">            first =  first!.next</div><div class="line">        &#125;</div><div class="line">        let firstStr = String(head.val)</div><div class="line">        guard  printStr != &quot;&quot; else &#123;</div><div class="line">            print(firstStr)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        printStr = firstStr.appending(&quot;-&gt;\(printStr)&quot;)</div><div class="line">        print(printStr)</div><div class="line">    &#125;</div><div class="line">    //交换相邻节点</div><div class="line">    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;</div><div class="line">        var h = head</div><div class="line">        var current = head</div><div class="line">        var f: ListNode?</div><div class="line">        var s: ListNode?</div><div class="line">        if head == nil &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">        if head?.next == nil &#123;</div><div class="line">            return head</div><div class="line">        &#125;</div><div class="line">        // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</div><div class="line">        //1.</div><div class="line">        let temp = current?.next</div><div class="line">        //2. </div><div class="line">        current?.next = (temp?.next)!</div><div class="line">        //3. </div><div class="line">        temp?.next = current!</div><div class="line">        //4. </div><div class="line">        h = temp  </div><div class="line">        //5. </div><div class="line">        while current?.next != nil &amp;&amp; current?.next?.next != nil &#123;</div><div class="line">            //6.  </div><div class="line">            f = current?.next</div><div class="line">            s = f?.next</div><div class="line">            //7.   </div><div class="line">            current?.next = s</div><div class="line">            //8. </div><div class="line">            f?.next = s?.next</div><div class="line">            //9. </div><div class="line">            s?.next = f</div><div class="line">            //10. </div><div class="line">            current = f</div><div class="line">        &#125;</div><div class="line">        return h</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>获取到刚开始的节点 如获取节点2: 1 -&gt; 2</li>
<li>将1的节点换成2后边的节点 如 1-&gt;3-&gt;4-&gt;5-&gt;6</li>
<li>将2的节点换成1 如 2-&gt;1-&gt;3-&gt;4-&gt;5-&gt;6</li>
<li>将2做为头节点</li>
<li>通过判断位置的节点的后节点和再后节点  如:判断列表 2-&gt;1-&gt;3-&gt;4-&gt;5-&gt;6  节点的3.4节点是否存在</li>
<li>存在即开始替换. 将3，4 节点进行替换,我们都知道如果替换两个值得话，要使用临时成员变量来记录</li>
<li>将当前节点的下一个节点先赋值 如 2-&gt;1-&gt;4-&gt;5-&gt;6</li>
<li>将4的下一个节点5改为3的下一个节点  如  2-&gt;1-&gt;4  3-&gt;5-&gt;6</li>
<li>当前4节点的下一个节点的改为3  如 2-&gt;1-&gt;4-&gt;3-&gt;5-&gt;6</li>
<li>重新设置当前的节点为3,开始排序5，6节点</li>
</ol>
<p><img src="http://ocar0timh.bkt.clouddn.com/A39EF414-F11F-4E0C-8ECA-66F05AC3B25F.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法7-整合两个已经排好序的链表,重新生成一个新的链表</title>
    <link href="http://blog.img421.com/2016/11/02/%E7%AE%97%E6%B3%957-%E6%95%B4%E5%90%88%E4%B8%A4%E4%B8%AA%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8,%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.img421.com/2016/11/02/算法7-整合两个已经排好序的链表,重新生成一个新的链表/</id>
    <published>2016-11-02T08:30:10.000Z</published>
    <updated>2016-11-02T09:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>整合两个已经排好序的链表,重新返回一个新的链表.这个新的链表由两个链表的头部拼接而成.</p>
<blockquote>
<p>example: </p>
<p>链表1: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>链表2: 3-&gt;4-&gt;5-&gt;6-&gt;7</p>
<p>输出:  1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5-&gt;5-&gt;6-&gt;7</p>
</blockquote>
<p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm/tree/master" target="_blank" rel="external">源码</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ListNode &#123;</div><div class="line">    var node: Int</div><div class="line">    var nextNode: ListNode?</div><div class="line">    init(node: Int) &#123;</div><div class="line">        self.node = node</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    //输出链表</div><div class="line">    func showList(head: ListNode)  &#123;</div><div class="line">        var printStr: String =  &quot;&quot;</div><div class="line">        var first = head.nextNode</div><div class="line">        while (first != nil) &#123;</div><div class="line">            if  first!.nextNode != nil &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.node)-&gt;&quot;)</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.node)&quot;)</div><div class="line">            &#125;</div><div class="line">            first =  first!.nextNode</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        let firstStr = String(head.node)</div><div class="line">        guard  printStr != &quot;&quot; else &#123;</div><div class="line">            print(firstStr)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        printStr = firstStr.appending(&quot;-&gt;\(printStr)&quot;)</div><div class="line">        print(printStr)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">       //整合链表</div><div class="line">    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;</div><div class="line">        if l1 == nil &#123;</div><div class="line">            return l2</div><div class="line">        &#125;</div><div class="line">        if l2 == nil &#123;</div><div class="line">            return l1</div><div class="line">        &#125;</div><div class="line">        //1.</div><div class="line">        if l1!.node &gt; l2!.node &#123;</div><div class="line">            </div><div class="line">            //2.</div><div class="line">            let  temp = l2</div><div class="line">            //3. </div><div class="line">            temp!.nextNode =  mergeTwoLists(l1, temp!.nextNode)</div><div class="line">            return temp</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            //2. </div><div class="line">            let temp = l1</div><div class="line">            //3. </div><div class="line">            temp!.nextNode =  mergeTwoLists(temp!.nextNode , l2)</div><div class="line">            return temp</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.通过判断节点上的值</li>
<li>2.获取到新链表的头部</li>
<li>3.循环得到节点的下一个节点</li>
</ul>
<p><img src="http://ocar0timh.bkt.clouddn.com/52EB3D92-0B21-4BDD-8BC8-DDAFEFE3CA2A.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法6-删除链表中倒数第n个节点</title>
    <link href="http://blog.img421.com/2016/10/31/shanchu-lianbiao-zhong-daoshu-di-n-ge-jiedian/"/>
    <id>http://blog.img421.com/2016/10/31/shanchu-lianbiao-zhong-daoshu-di-n-ge-jiedian/</id>
    <published>2016-10-31T08:30:28.000Z</published>
    <updated>2016-11-18T03:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>给出一个链表1-&gt;2-&gt;3-&gt;4-&gt;5和n=2,</p>
<p>通过移除倒数第二个节点,重新得到它的首节点,使链表输出成为1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p><strong>注:给出的n总是有效的</strong><br><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">class ListNode:Equatable &#123;</div><div class="line">    var node: Int</div><div class="line">    var nextNode: ListNode?</div><div class="line">    init(node: Int) &#123;</div><div class="line">        self.node = node</div><div class="line">    &#125;</div><div class="line">    public static func ==(lhs: ListNode, rhs: ListNode) -&gt; Bool</div><div class="line">    &#123;</div><div class="line">        return lhs.node == rhs.node &amp;&amp; lhs.nextNode == rhs.nextNode</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Solution &#123;</div><div class="line">    </div><div class="line">    //输出链表</div><div class="line">    func showList(head: ListNode)  &#123;</div><div class="line">        var printStr: String =  &quot;&quot;</div><div class="line">        var first = head.nextNode</div><div class="line">        while (first != nil) &#123;</div><div class="line">            if  first!.nextNode != nil &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.node)-&gt;&quot;)</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                printStr =   printStr.appending(&quot;\(first!.node)&quot;)</div><div class="line">            &#125;</div><div class="line">            first =  first!.nextNode</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        let firstStr = String(head.node)</div><div class="line">        guard  printStr != &quot;&quot; else &#123;</div><div class="line">            print(firstStr)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        printStr = firstStr.appending(&quot;-&gt;\(printStr)&quot;)</div><div class="line">        print(printStr)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;</div><div class="line">        </div><div class="line">        var h = head</div><div class="line">        var p1,p2,pre: ListNode?</div><div class="line">        </div><div class="line">        if head == nil || n &lt;= 0 &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">        p1 = head</div><div class="line">        p2 = head</div><div class="line">        </div><div class="line">        var i = 0</div><div class="line">        //1. </div><div class="line">        while i &lt; n-1 &#123;</div><div class="line">            p1 = p1?.nextNode</div><div class="line">            if p1==nil &#123;</div><div class="line">                return nil</div><div class="line">            &#125;</div><div class="line">            i+=1</div><div class="line">        &#125;</div><div class="line">        //2. </div><div class="line">        while p1?.nextNode != nil &#123;</div><div class="line">            p1 = p1?.nextNode</div><div class="line">        //3.</div><div class="line">            pre = p2   </div><div class="line">            p2 = p2?.nextNode</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if p2 == head &#123;</div><div class="line">            h = head?.nextNode</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">        //4. </div><div class="line">       	pre?.nextNode = pre?.nextNode?.nextNode</div><div class="line">        &#125;</div><div class="line">        // 5. </div><div class="line">        return h</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.遍历n-1次,是为了获取到(2)中的p2位置.</li>
<li>2.获取倒数n的节点</li>
<li>3.此目的是为了要获取倒数节点的上一个节点,然后重新设置*    (4)上一个节点的nextNode</li>
<li>4.重新设置上一个节点的nextNode</li>
<li>5.此步骤和以上步骤没有任何关系,只是重新返回头节点,保证输出是从head(头节点)开始</li>
</ul>
<p><img src="http://ocar0timh.bkt.clouddn.com/60F728FE-3CB4-4860-AF9A-68FEDCDA879F.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给出一个链表1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5和n=2,&lt;/p&gt;
&lt;p&gt;通过移除倒数第二个节点,重新得到它的首节点,使链表输出成为1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法5-字符串数组中获取最长的公共前缀</title>
    <link href="http://blog.img421.com/2016/10/28/zui-chang-de-common-prefix/"/>
    <id>http://blog.img421.com/2016/10/28/zui-chang-de-common-prefix/</id>
    <published>2016-10-28T07:03:30.000Z</published>
    <updated>2016-10-28T07:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串数组中获取最长的公共前缀"><a href="#字符串数组中获取最长的公共前缀" class="headerlink" title="字符串数组中获取最长的公共前缀"></a>字符串数组中获取最长的公共前缀</h2><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>
<p>意思是: 写一个从字符串数组中获取最长公共前缀的函数.</p>
<p>编程之前我们要先了解到:</p>
<ol>
<li>如果有相同的前缀,那么肯定首字母相同;</li>
<li>如果没有相同的前缀，那么不管如何都是返回为空字符串(“”)</li>
</ol>
<p><strong>因此我们可以先进行排序,然后通过第一个和最后一个的字符串进行比较,获取是否有公共字符串</strong></p>
<p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct LongestCommonPrefix &#123;</div><div class="line">   static func Solution(sArrs: [String]) -&gt; String &#123;</div><div class="line">        //判读数组</div><div class="line">        if sArrs.isEmpty &#123;</div><div class="line">            return &quot;&quot;</div><div class="line">        &#125;</div><div class="line">        if sArrs.count == 1 &#123;</div><div class="line">            return sArrs.first!</div><div class="line">        &#125;</div><div class="line">        let strArrs = sArrs.sorted()</div><div class="line">        let firstStr = strArrs.first!</div><div class="line">        let endStr = strArrs.last!</div><div class="line">        var i = 0</div><div class="line">        let length = min(firstStr.characters.count, endStr.characters.count)</div><div class="line">        </div><div class="line">        while i &lt; length &amp;&amp; firstStr[(firstStr.index(firstStr.startIndex, offsetBy: i))] == endStr[endStr.index(endStr.startIndex, offsetBy: i)]</div><div class="line">        &#123;</div><div class="line">            i+=1</div><div class="line">        &#125;</div><div class="line">        return firstStr.substring(to: firstStr.index(firstStr.startIndex, offsetBy: i))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串数组中获取最长的公共前缀&quot;&gt;&lt;a href=&quot;#字符串数组中获取最长的公共前缀&quot; class=&quot;headerlink&quot; title=&quot;字符串数组中获取最长的公共前缀&quot;&gt;&lt;/a&gt;字符串数组中获取最长的公共前缀&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Write
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法4-将罗马数字转换为整数</title>
    <link href="http://blog.img421.com/2016/10/27/%E7%AE%97%E6%B3%954-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/"/>
    <id>http://blog.img421.com/2016/10/27/算法4-罗马数字转换为整数/</id>
    <published>2016-10-27T07:50:29.000Z</published>
    <updated>2016-10-28T06:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给出一个罗马数-将其转换为整数"><a href="#给出一个罗马数-将其转换为整数" class="headerlink" title="给出一个罗马数,将其转换为整数."></a>给出一个罗马数,将其转换为整数.</h2><p>保证范围为1-3999.</p>
<p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<blockquote>
<p>罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）</p>
</blockquote>
<p>计数方式 :    <a href="http://baike.baidu.com/link?url=OtUwcBrsZYHwhgHXm4HIxgVnrhU0bD5yNuxXYxSVP6flX8-CMXjuPU1aJcIIyHw4VnwLaquM6uhqhMi0ZXMdO_" target="_blank" rel="external">百度百科</a>、<a href="https://zh.wikipedia.org/zh-hans/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97" target="_blank" rel="external">维基百科</a></p>
<ul>
<li>重复数次：一个罗马数字重复几次，就表示这个数的几倍。如 Ⅲ=3</li>
<li><p>右加左减</p>
<ul>
<li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12</li>
<li>小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9</li>
<li>右加数字不可连续超过三位，比如14写成XIV，而非XIIII。</li>
<li>左减数字必须为一位，比如8写成VIII，而非IIX。</li>
</ul>
</li>
<li><p>在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍,如果上方有两条横线，即是原数的1000000倍。</p>
</li>
<li>数码限制：<ul>
<li>同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL<br><a href="http://literacy.kent.edu/Minigrants/Cinci/romanchart.htm" target="_blank" rel="external">Roman Numerals Chart</a></li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="1-通过枚举-enum"><a href="#1-通过枚举-enum" class="headerlink" title="1.通过枚举(enum)"></a>1.通过枚举(enum)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">enum Roman: String &#123;</div><div class="line">    case I, V, X, L, C, D, M</div><div class="line">    </div><div class="line">    func getRomanValue() -&gt; Int &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .I:</div><div class="line">            return 1</div><div class="line">        case .V:</div><div class="line">            return 5</div><div class="line">        case .X:</div><div class="line">            return 10</div><div class="line">        case .L:</div><div class="line">            return 50</div><div class="line">        case .C:</div><div class="line">            return 100</div><div class="line">        case .D:</div><div class="line">            return 500</div><div class="line">        case .M:</div><div class="line">            return 1000</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //判断是否这三种类型，如果左边为三种则减</div><div class="line">    func isSubtract() -&gt; Bool &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .I,.X,.C :</div><div class="line">            return true</div><div class="line">        default:</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//0.根据索引获取字符串当前索引字符</div><div class="line">extension String  &#123;</div><div class="line">    </div><div class="line">    func characterAtIndex(index: Int) -&gt; Character? &#123;</div><div class="line">        var cur = 0</div><div class="line">        for char in self.characters &#123;</div><div class="line">            if cur == index &#123;</div><div class="line">                return char</div><div class="line">            &#125;</div><div class="line">            cur += 1</div><div class="line">        &#125;</div><div class="line">        return nil</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//罗马数 -&gt; 整数</div><div class="line">class Solution &#123;</div><div class="line">    static func romanToInt(s: String) -&gt; Int &#123;</div><div class="line">        var intValue = 0</div><div class="line">        if s.characters.count == 1 &#123;</div><div class="line">            return Roman(rawValue: s)!.getRomanValue()</div><div class="line">        &#125;</div><div class="line">        //1.</div><div class="line">        let c_reversed = s.characters.reversed()</div><div class="line">        for (index,c) in c_reversed.enumerated() &#123;</div><div class="line">            </div><div class="line">            if (index+1) % 2  == 0 &#123;</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            let roman_after = Roman(rawValue: String.init(c))</div><div class="line">            //2.</div><div class="line">            if (index+1 == s.characters.count) &#123;</div><div class="line">                return roman_after!.getRomanValue()+intValue</div><div class="line">            &#125;</div><div class="line">              </div><div class="line">            let c_curr = String(c_reversed).characterAtIndex(index: index+1)!</div><div class="line">            let roman =  Roman(rawValue: String.init(c_curr))</div><div class="line">      	  		//3.</div><div class="line">            if ((roman_after!.getRomanValue() &gt; roman!.getRomanValue()) &amp;&amp;  roman!.isSubtract())</div><div class="line">            &#123;</div><div class="line">                    intValue =  intValue + roman_after!.getRomanValue() - roman!.getRomanValue()</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                    intValue =  intValue + roman_after!.getRomanValue() + roman!.getRomanValue()</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">        &#125;</div><div class="line">        return intValue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>反转字符为字符数组.目的: 使罗马数从右向左依次计算</li>
<li>判断如果为最后一个,则整合全部的数</li>
<li>通过判断左边的字符值和右边的字符值比较大小，并且左边的字符符合罗马数I、X、L 时,则大的减去小的</li>
</ol>
</blockquote>
<p><strong>以上的枚举通过使用字典存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">class Solution1 &#123;</div><div class="line"></div><div class="line">        var romanDic: [String: Int] = [&quot;I&quot;: 1,</div><div class="line">                                       &quot;V&quot;: 5,</div><div class="line">                                       &quot;X&quot;: 10,</div><div class="line">                                       &quot;L&quot;: 50,</div><div class="line">                                       &quot;C&quot;: 100,</div><div class="line">                                       &quot;D&quot;: 500,</div><div class="line">                                       &quot;M&quot;: 1000]</div><div class="line">        func romanToInt(s: String) -&gt; Int &#123;</div><div class="line">            if s.characters.count == 1 &#123;</div><div class="line">                return romanDic[s] == nil ? romanDic[s]! : 0</div><div class="line">        &#125;</div><div class="line">        //1.</div><div class="line">                let c_reversed = s.characters.reversed()</div><div class="line">        var intValue = 0</div><div class="line"></div><div class="line">        for (index,c) in c_reversed.enumerated() &#123;</div><div class="line">            if (index+1) % 2  == 0 &#123;</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            let c_after_value = romanDic[String(c)]!</div><div class="line">            </div><div class="line">            if (index+1) == s.characters.count&#123;</div><div class="line">                return c_after_value + intValue</div><div class="line">            &#125;</div><div class="line">            let c_curr = String(c_reversed).characterAtIndex(index: index+1)!</div><div class="line">            let c_curr_value = romanDic[String(c_curr)]!</div><div class="line">            if (c_after_value &gt; c_curr_value) &amp;&amp; (c_curr_value == 1 || c_curr_value == 10 || c_curr_value == 100)&#123;</div><div class="line">            intValue = intValue + c_after_value - c_curr_value</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">            intValue = intValue + c_after_value + c_curr_value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            return intValue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>对于根据索引获取字符串中的字符同样可以使用<br><strong>index(_ i: String.Index, offsetBy n: String.IndexDistance) -&gt; String.Index</strong> 获取得到</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> let s = &quot;Swift&quot;</div><div class="line"> let i = s.index(s.startIndex, offsetBy: 4)</div><div class="line"> print(s[i])</div><div class="line">// Prints &quot;t&quot;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h2><p>使用一些特殊的罗马数进行测试:</p>
<p><strong>XIV  -&gt;  14</strong></p>
<p><img src="http://ocar0timh.bkt.clouddn.com/CC2275E1-39A6-4E5B-83BC-365C393C0BA4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;给出一个罗马数-将其转换为整数&quot;&gt;&lt;a href=&quot;#给出一个罗马数-将其转换为整数&quot; class=&quot;headerlink&quot; title=&quot;给出一个罗马数,将其转换为整数.&quot;&gt;&lt;/a&gt;给出一个罗马数,将其转换为整数.&lt;/h2&gt;&lt;p&gt;保证范围为1-3999.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法3-判断一个整数是回文数</title>
    <link href="http://blog.img421.com/2016/10/25/%E7%AE%97%E6%B3%953-%E5%9B%9E%E6%96%87%E6%95%B4%E6%95%B0/"/>
    <id>http://blog.img421.com/2016/10/25/算法3-回文整数/</id>
    <published>2016-10-25T07:40:48.000Z</published>
    <updated>2016-10-27T09:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给出一个整形判断是否是回文数"><a href="#给出一个整形判断是否是回文数" class="headerlink" title="给出一个整形判断是否是回文数"></a>给出一个整形判断是否是回文数</h2><p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a><br>1.不考虑整形溢出;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/// 回文数</div><div class="line">class Solution1 &#123;</div><div class="line">    func isPalindrome(x: Int) -&gt; Bool &#123;</div><div class="line">        if (x&lt;0  || (x != 0 &amp;&amp; x % 10 == 0)) &#123;return false&#125;  //判断小0,并且尾数为0的数</div><div class="line">        var tmpX = x</div><div class="line">        var result = 0</div><div class="line">        while tmpX &gt; 0 &#123;</div><div class="line">            result = tmpX % 10 + result * 10</div><div class="line">            tmpX = tmpX / 10</div><div class="line">        &#125;</div><div class="line">        return result == x</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;给出一个整形判断是否是回文数&quot;&gt;&lt;a href=&quot;#给出一个整形判断是否是回文数&quot; class=&quot;headerlink&quot; title=&quot;给出一个整形判断是否是回文数&quot;&gt;&lt;/a&gt;给出一个整形判断是否是回文数&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://githu
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法2-反转整形</title>
    <link href="http://blog.img421.com/2016/10/24/%E7%AE%97%E6%B3%952-%E5%8F%8D%E8%BD%AC%E6%95%B4%E5%BD%A2/"/>
    <id>http://blog.img421.com/2016/10/24/算法2-反转整形/</id>
    <published>2016-10-24T04:30:48.000Z</published>
    <updated>2016-10-27T09:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从入门到“崩溃”,算法是硬伤.</p>
</blockquote>
<h2 id="反转整形"><a href="#反转整形" class="headerlink" title="反转整形"></a>反转整形</h2><p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Example1: x = 123, return 321</div><div class="line"></div><div class="line">Example2: x = -123, return -321</div></pre></td></tr></table></figure>
<h4 id="1-字符串法"><a href="#1-字符串法" class="headerlink" title="1.字符串法"></a>1.字符串法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution&#123;</div><div class="line">    /// 字符串法</div><div class="line">    func reverse(x: Int) -&gt; Int &#123; </div><div class="line">        var negative: Bool = false</div><div class="line">        var m : Int = 0</div><div class="line">        if x &lt; 0 &#123; </div><div class="line">            m = x * -1</div><div class="line">            negative = true</div><div class="line">        &#125;</div><div class="line">        var xStr = String(m)</div><div class="line">        let c: [Character] =  xStr.characters.reversed()</div><div class="line">        let rStr = String(c)</div><div class="line">        if negative &#123;</div><div class="line">            return   -Int(rStr)!</div><div class="line">        &#125;</div><div class="line">            return Int(rStr)!;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-模十法"><a href="#2-模十法" class="headerlink" title="2.模十法"></a>2.模十法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution&#123;</div><div class="line">    /// 模十法</div><div class="line">    func reverseMo10(x: Int) -&gt; Int &#123;</div><div class="line">        var result = 0</div><div class="line">        var tmp = abs(x)</div><div class="line">        while tmp &gt; 0 &#123;</div><div class="line">            result = result*10 + tmp%10</div><div class="line">            tmp/=10</div><div class="line">        &#125;</div><div class="line">        return x &gt; 0 ? result : -result</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从入门到“崩溃”,算法是硬伤.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;反转整形&quot;&gt;&lt;a href=&quot;#反转整形&quot; class=&quot;headerlink&quot; title=&quot;反转整形&quot;&gt;&lt;/a&gt;反转整形&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;htt
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法1-取出整形数组中的两数之和是给出值得数组</title>
    <link href="http://blog.img421.com/2016/10/24/%E7%AE%97%E6%B3%951-%E5%8F%96%E5%87%BA%E6%95%B4%E5%BD%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%87%BA%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0/"/>
    <id>http://blog.img421.com/2016/10/24/算法1-取出整形数组中和为给出值的整数/</id>
    <published>2016-10-24T03:40:48.000Z</published>
    <updated>2016-10-27T09:33:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给出一个内容不同的整形数组-使其中两数之和为所给的目标值-返回两数的索引值"><a href="#给出一个内容不同的整形数组-使其中两数之和为所给的目标值-返回两数的索引值" class="headerlink" title="给出一个内容不同的整形数组,使其中两数之和为所给的目标值,返回两数的索引值"></a>给出一个内容不同的整形数组,使其中两数之和为所给的目标值,返回两数的索引值</h2><p><a href="https://github.com/twenty-zp/LeetCodeAlgorithm.git" target="_blank" rel="external">源代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Example:</div><div class="line">	Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">	Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">	return [0, 1].</div></pre></td></tr></table></figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/// 取出整形数组中的两数之和是给出值得数组</div><div class="line">class Solution &#123;</div><div class="line">    /**</div><div class="line">     - parameter nums:   整数数组</div><div class="line">     - parameter target: 目标和</div><div class="line">     - returns: 返回一个数组</div><div class="line">     */</div><div class="line">    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;</div><div class="line">        //1.</div><div class="line">        var hash: [Int: Int] = [:]</div><div class="line">        var result: [Int] = []</div><div class="line">        for(i,n) in nums.enumerated() &#123;</div><div class="line">            //2.</div><div class="line">            if let index = hash[target - n] &#123;</div><div class="line">                result.append(index)</div><div class="line">                result.append(i)</div><div class="line">            &#125;</div><div class="line">            //3.</div><div class="line">            hash[n] = i</div><div class="line">        &#125;</div><div class="line">        return result</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>1.定义一个字典(Dictionary),为了从中判断是否存在<code>2</code>中内容;<br>2.通过目标值<code>-</code>(减去)遍历获取的值,去判断是否索引值,因为在<code>3</code>中将值和索引进行互换.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;给出一个内容不同的整形数组-使其中两数之和为所给的目标值-返回两数的索引值&quot;&gt;&lt;a href=&quot;#给出一个内容不同的整形数组-使其中两数之和为所给的目标值-返回两数的索引值&quot; class=&quot;headerlink&quot; title=&quot;给出一个内容不同的整形数组,使其中两
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://blog.img421.com/tags/LeetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Xcode8 安装Alcatraz使用插件</title>
    <link href="http://blog.img421.com/2016/09/23/Xcode8%20%E5%AE%89%E8%A3%85Alcatraz%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.img421.com/2016/09/23/Xcode8 安装Alcatraz使用插件/</id>
    <published>2016-09-23T09:34:49.000Z</published>
    <updated>2016-04-25T05:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>苹果从Xcode 8开始对于Alcatraz中安装的插件已经不支持,这可能是因为Xcode-ghost事件,让苹果认为未审核过的插件也会不安全,因此苹果在Xcode 8 中提供了开发插件的扩展.<br><a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">Using and Extending the Xcode Source Editor</a>.但是我们使用插件已经习惯性和方便,所以本章节为<strong>在Xcode 8 中安装Alcatraz</strong></p>
</blockquote>
<h2 id="更新2016-11-02"><a href="#更新2016-11-02" class="headerlink" title="更新2016-11-02"></a>更新2016-11-02</h2><p><strong>请运行一次官方Xcode8,再打开此插件生成的Xcode版本.</strong></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>通过以下命令安装<strong>xcode plugins</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install update_xcode_plugins</div></pre></td></tr></table></figure>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>如果安装好了,可以使用以下再命令行中查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update_xcode_plugins</div></pre></td></tr></table></figure>
<p><img src="http://7xoj45.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-23%20%E4%B8%8B%E5%8D%885.44.16.png" alt=""></p>
<h2 id="3-使用插件"><a href="#3-使用插件" class="headerlink" title="3.使用插件"></a>3.使用插件</h2><p>当确认安装好以后,通过提示运行以下命令,默认颜色是选择<strong>Cancel</strong>,可以通过使用键盘上下键,来选择<strong>Xcode 8.0</strong>等待安装.此安装会等待长时间,因为相当于copy一份Xcode.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update_xcode_plugins --unsign</div></pre></td></tr></table></figure>
<p><img src="http://7xoj45.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-23%20%E4%B8%8B%E5%8D%885.46.41.png" alt=""></p>
<h2 id="4-安装成功"><a href="#4-安装成功" class="headerlink" title="4.安装成功"></a>4.安装成功</h2><p>当安装成功以后会给你跳出<strong>Finished!</strong>,你可以到你<strong>应用程序</strong>或者<strong>Launchpad</strong>中查看到一个<strong>Xcode-unsign</strong>命名的Xcode版本.打开此版本即可.<br><img src="http://7xoj45.com1.z0.glb.clouddn.com/xcode8.0.png" alt=""><br><img src="http://7xoj45.com1.z0.glb.clouddn.com/5130115C-C9A4-400F-B205-5122F0CD1309.png" alt=""></p>
<p>###工具<br><a href="https://github.com/inket/update_xcode_plugins" target="_blank" rel="external">update_xcode_plugins</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;苹果从Xcode 8开始对于Alcatraz中安装的插件已经不支持,这可能是因为Xcode-ghost事件,让苹果认为未审核过的插件也会不安全,因此苹果在Xcode 8 中提供了开发插件的扩展.&lt;br&gt;&lt;a href=&quot;https://develo
    
    </summary>
    
    
      <category term=" - Twenty随笔录" scheme="http://blog.img421.com/tags/Twenty%E9%9A%8F%E7%AC%94%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Ghost博客迁移Hexo历程</title>
    <link href="http://blog.img421.com/2016/09/21/ghost%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhexo%E5%8E%86%E7%A8%8B/"/>
    <id>http://blog.img421.com/2016/09/21/ghost博客迁移hexo历程/</id>
    <published>2016-09-21T02:45:30.000Z</published>
    <updated>2016-09-21T02:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<pre><code>在亚马逊云服务(简称AWS)到期之前,因为将服务器的到期时间搞错,所以数据没有给export 出来.
幸运的是到期后的两周内云服务器卷宗和实例还都在,就又重新启动一个新的实例绑定卷宗,
通过远程获取到MySQL数据库Copy到本地。
</code></pre></blockquote>
<p>1.获取到MySQL打开后的数据库为文件夹,内部都是一些<code>.frm</code>文件,因此要安装本地MySQL服务器,通过同名数据库,<code>Copy</code>所有的<code>.frm</code>文件到本地MySQL服务器中,除此之外<code>ib_logfile0</code>、<code>ib_logfile1</code>、<code>ibdata1</code>文件也要复制进去.</p>
<p>2.启动MySQL.</p>
<p>3.通过<code>Navicate Premium</code>或命令打开数据库查看表中内容.</p>
<p>注:MySQL默认为<code>latin1</code>字符集,因此如果我们打开表会看到乱码.因此要将MySQL中的<code>my-defalut.cnf</code> 复制一份到<code>/etc</code>下,并命名为<code>my.cnf</code>.再<code>my.cnf</code>的<code>[mysqld]</code>下,添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">init-connect = &apos;set names latin1&apos;</div><div class="line">character-set-server = latin1</div></pre></td></tr></table></figure>
<p>4.重新启动MySQL查看内容,显示为非乱码.</p>
<p>5.本地安装ghost博客,使用<code>MySQL</code>数据库,名称为本地的数据库名称。</p>
<p>6.运行ghost博客,进入到后台可以重新<code>export</code>json文件数据.</p>
<p>7.安装Hexo,使用ghost-hexo 插件转json内容为<code>markdown</code>文件.</p>
<p>8.hexo生成html,并上传到coding、github等.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;在亚马逊云服务(简称AWS)到期之前,因为将服务器的到期时间搞错,所以数据没有给export 出来.
幸运的是到期后的两周内云服务器卷宗和实例还都在,就又重新启动一个新的实例绑定卷宗,
通过远程获取到MySQL数据库Copy到本地。
    
    </summary>
    
    
      <category term=" - 博客" scheme="http://blog.img421.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>四、视频的编解码-编码篇</title>
    <link href="http://blog.img421.com/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/"/>
    <id>http://blog.img421.com/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/</id>
    <published>2016-08-05T02:21:42.000Z</published>
    <updated>2016-08-05T08:09:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的编解码,占用CPU资源,效率低下,俗称软编解码.而苹果在2014年的iOS8中,开放了VideoToolbox.framwork框架,此框架使用GPU或专用的处理器来进行编解码,俗称硬编解码.而此框架在此之前只有MAC OS系统中可以使用,在iOS作为私有框架.终于苹果在iOS8.0中得到开放引入.</p>
<p>2014年的WWDC<a href="https://developer.apple.com/videos/play/wwdc2014/513/" target="_blank" rel="external">Direct Access to Video Encoding and Decoding</a>中,苹果介绍了使用videoToolbox硬编解码.<br>使用硬编解码有几个优点:</p>
<ul>
<li>提高性能;</li>
<li>增加效率;</li>
<li>延长电量的使用</li>
</ul>
<p>对于编解码,AVFoundation框架只有以下几个功能:</p>
<ol>
<li>直接解压后显示;</li>
<li>直接压缩到一个文件当中;</li>
</ol>
<p>而对于Video Toolbox,我们可以通过以下功能获取到数据,进行网络流传输等多种保存：</p>
<ol>
<li>解压为图像的数据结构;</li>
<li><p>压缩为视频图像的容器数据结构.</p>
<h3 id="一、videoToolbox的基本数据"><a href="#一、videoToolbox的基本数据" class="headerlink" title="一、videoToolbox的基本数据"></a>一、videoToolbox的基本数据</h3><p>Video Toolbox视频编解码前后需要应用的数据结构进行说明。</p>
</li>
<li><p>CVPixelBuffer：编码前和解码后的图像数据结构。此内容包含一系列的CVPixelBufferPool内容</p>
</li>
<li><p>CMTime、CMClock和CMTimebase：时间戳相关。时间以64-bit/32-bit的形式出现。</p>
</li>
<li><p>pixelBufferAttributes:字典设置.可能包括Width/height、pixel format type、• Compatibility (e.g., OpenGL ES, Core Animation)</p>
</li>
<li><p>CMBlockBuffer：编码后，结果图像的数据结构。</p>
</li>
<li><p>CMVideoFormatDescription：图像存储方式，编解码器等格式描述。</p>
</li>
<li><p>(CMSampleBuffer：存放编解码前后的视频图像的容器数据结构。</p>
</li>
<li><p>CMClock </p>
</li>
<li><p>CMTimebase: 关于CMClock的一个控制视图,包含CMClock、时间映射(Time mapping)、速率控制(Rate control)</p>
</li>
</ol>
<hr>
<p>由<a href="er_3001_cai_ji_shi_pin.md">二、采集视频数据</a>可知,我们获取到的数据<code>(CMSampleBufferRef)sampleBuffer</code>为未编码的数据;</p>
<p><img src="https://twenty-zp.gitbooks.io/-/content/AFBF71FB-4A38-449B-97FC-EBE4BAC1A3F6.png" alt="图1.1编码前后的数据结构示意图"><br><strong>图1.1</strong><br>上图中,编码前后的视频图像都封装在<code>CMSampleBuffer</code>中,编码前以<code>CVPixelBuffer</code>进行存储;编码后以<code>CMBlockBuffer</code>进行存储。除此之外两者都包括<code>CMTime</code>、<code>CMVideoFormatDesc</code>.</p>
<h3 id="二、视频数据流编码并上传到服务器"><a href="#二、视频数据流编码并上传到服务器" class="headerlink" title="二、视频数据流编码并上传到服务器"></a>二、视频数据流编码并上传到服务器</h3><p><img src="https://twenty-zp.gitbooks.io/-/content/4218AA54-612D-4C96-92D6-1DC9E6358142.png" alt="图2.1"></p>
<h4 id="1-将CVPixelBuffer使用VTCompressionSession进行数据流的硬编码。"><a href="#1-将CVPixelBuffer使用VTCompressionSession进行数据流的硬编码。" class="headerlink" title="1.将CVPixelBuffer使用VTCompressionSession进行数据流的硬编码。"></a>1.将CVPixelBuffer使用VTCompressionSession进行数据流的硬编码。</h4><h5 id="1-初始化VTCompressionSession"><a href="#1-初始化VTCompressionSession" class="headerlink" title="(1)初始化VTCompressionSession"></a>(1)初始化VTCompressionSession</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">VT_EXPORT OSStatus </div><div class="line">VTCompressionSessionCreate(</div><div class="line">	CM_NULLABLE CFAllocatorRef							allocator,</div><div class="line">	int32_t												width,</div><div class="line">	int32_t												height,</div><div class="line">	CMVideoCodecType									codecType,</div><div class="line">	CM_NULLABLE CFDictionaryRef							encoderSpecification,</div><div class="line">	CM_NULLABLE CFDictionaryRef							sourceImageBufferAttributes,</div><div class="line">	CM_NULLABLE CFAllocatorRef							compressedDataAllocator,</div><div class="line">	CM_NULLABLE VTCompressionOutputCallback				outputCallback,</div><div class="line">	void * CM_NULLABLE									outputCallbackRefCon,</div><div class="line">	CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef * CM_NONNULL compressionSessionOut)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_8_0);</div></pre></td></tr></table></figure>
<blockquote>
<p>VTCompressionSession的初始化参数说明:</p>
<ul>
<li>allocator:分配器,设置NULL为默认分配</li>
<li>width: 宽</li>
<li>height: 高</li>
<li>codecType: 编码类型,如kCMVideoCodecType_H264</li>
<li>encoderSpecification: 编码规范。设置NULL由videoToolbox自己选择</li>
<li>sourceImageBufferAttributes: 源像素缓冲区属性.设置NULL不让videToolbox创建,而自己创建</li>
<li>compressedDataAllocator: 压缩数据分配器.设置NULL,默认的分配</li>
<li>outputCallback: 当VTCompressionSessionEncodeFrame被调用压缩一次后会被异步调用.<strong>注:当你设置NULL的时候,你需要调用VTCompressionSessionEncodeFrameWithOutputHandler方法进行压缩帧处理,支持iOS9.0以上</strong></li>
<li>outputCallbackRefCon: 回调客户定义的参考值.</li>
<li>compressionSessionOut: 压缩会话变量。</li>
</ul>
</blockquote>
<h5 id="2-配置VTCompressionSession"><a href="#2-配置VTCompressionSession" class="headerlink" title="(2)配置VTCompressionSession"></a>(2)配置VTCompressionSession</h5><p>  使用VTSessionSetProperty()调用进行配置compression。<br>  <img src="https://twenty-zp.gitbooks.io/-/content/3EFF1058-1A5B-45E9-B7F3-21BA58C232F2.png" alt=""></p>
<blockquote>
<ul>
<li>kVTCompressionPropertyKey_AllowFrameReordering: 允许帧重新排序.默认为true</li>
<li>kVTCompressionPropertyKey_AverageBitRate: 设置需要的平均编码率</li>
<li>kVTCompressionPropertyKey_H264EntropyMode：H264的<a href="http://baike.baidu.com/view/182718.htm" target="_blank" rel="external">熵编码</a>模式。有两种模式:一种基于上下文的二进制算数编码CABAC和可变长编码VLC.在slice层之上（picture和sequence）使用定长或变长的二进制编码，slice层及其以下使用VLC或CABAC.<a href="http://www.programgo.com/article/71134070443/" target="_blank" rel="external">详情请参考</a></li>
<li>kVTCompressionPropertyKey_RealTime: 视频编码压缩是否是实时压缩。可设置CFBoolean或NULL.默认为NULL</li>
<li>kVTCompressionPropertyKey_ProfileLevel: 对于编码流指定配置和标准 .比如kVTProfileLevel_H264_Main_AutoLevel</li>
</ul>
</blockquote>
<p>配置过VTCompressionSession后,可以可选的调用<code>VTCompressionSessionPrepareToEncodeFrames</code>进行准备工作编码帧。</p>
<h5 id="3-开始硬编码流入的数据"><a href="#3-开始硬编码流入的数据" class="headerlink" title="(3)开始硬编码流入的数据"></a>(3)开始硬编码流入的数据</h5><p>使用<code>VTCompressionSessionEncodeFrame</code>方法进行编码.当编码结束后调用outputCallback回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VT_EXPORT OSStatus</div><div class="line">VTCompressionSessionEncodeFrame(</div><div class="line">	CM_NONNULL VTCompressionSessionRef	session,</div><div class="line">	CM_NONNULL CVImageBufferRef			imageBuffer,</div><div class="line">	CMTime								presentationTimeStamp,</div><div class="line">	CMTime								duration, // may be kCMTimeInvalid</div><div class="line">	CM_NULLABLE CFDictionaryRef			frameProperties,</div><div class="line">	void * CM_NULLABLE					sourceFrameRefCon,</div><div class="line">	VTEncodeInfoFlags * CM_NULLABLE		infoFlagsOut )</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_8_0);</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>presentationTimeStamp： 获取到的这个sample buffer数据的展示时间戳。每一个传给这个session的时间戳都要大于前一个展示时间戳.</li>
<li>duration: 对于获取到sample buffer数据,这个帧的展示时间.如果没有时间信息,可设置<code>kCMTimeInvalid</code>.</li>
<li>frameProperties: 包含这个帧的属性.帧的改变会影响后边的编码帧.</li>
<li>sourceFrameRefCon: 回调函数会引用你设置的这个帧的参考值.</li>
<li>infoFlagsOut: 指向一个<code>VTEncodeInfoFlags</code>来接受一个编码操作.如果使用异步运行,<code>kVTEncodeInfo_Asynchronous</code>被设置；同步运行,<code>kVTEncodeInfo_FrameDropped</code>被设置；设置NULL为不想接受这个信息.</li>
</ul>
</blockquote>
<h5 id="4-执行VTCompressionOutputCallback回调函数"><a href="#4-执行VTCompressionOutputCallback回调函数" class="headerlink" title="(4)执行VTCompressionOutputCallback回调函数"></a>(4)执行VTCompressionOutputCallback回调函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef void (*VTCompressionOutputCallback)(</div><div class="line">		void * CM_NULLABLE outputCallbackRefCon,</div><div class="line">		void * CM_NULLABLE sourceFrameRefCon, </div><div class="line">		OSStatus status, </div><div class="line">		VTEncodeInfoFlags infoFlags,</div><div class="line">		CM_NULLABLE CMSampleBufferRef sampleBuffer );</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>outputCallbackRefCon: 回调函数的参考值</li>
<li>sourceFrameRefCon: VTCompressionSessionEncodeFrame函数中设置的帧的参考值</li>
<li>status: 压缩的成功为noErr,如失败有错误码</li>
<li>infoFlags: 包含编码操作的信息标识</li>
<li>sampleBuffer: 如果压缩成功或者帧不丢失,则包含这个已压缩的数据CMSampleBuffer,否则为NULL</li>
</ul>
</blockquote>
<h5 id="5-将压缩成功的sampleBuffer数据进行处理为基本流NSData上传到服务器"><a href="#5-将压缩成功的sampleBuffer数据进行处理为基本流NSData上传到服务器" class="headerlink" title="(5)将压缩成功的sampleBuffer数据进行处理为基本流NSData上传到服务器"></a>(5)将压缩成功的sampleBuffer数据进行处理为基本流NSData上传到服务器</h5><blockquote>
<p>MPEG-4是一套用于音频、视频信息的压缩编码标准.</p>
</blockquote>
<p><img src="https://twenty-zp.gitbooks.io/-/content/9C31AACA-9BFA-4434-89DD-BFD4787F4038.png" alt="图5.1"><br>由<strong>图1.1</strong>可知,已压缩 $$CMSampleBuffer = CMTime(可选) + CMBlockBuffer + CMVideoFormatDesc$$。</p>
<p><strong>5.1 先判断压缩的数据是否正确</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//不存在则代表压缩不成功或帧丢失</div><div class="line"> if(!sampleBuffer) return;</div><div class="line"> if (status != noErr) return;</div><div class="line"> //返回sampleBuffer中包括可变字典的不可变数组,如果有错误则为NULL</div><div class="line">CFArrayRef  array =  CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true);</div><div class="line"> if (!array)  return;</div><div class="line"></div><div class="line">CFDictionaryRef dic = CFArrayGetValueAtIndex(array, 0);</div><div class="line"> if (!dic) return;</div><div class="line"> </div><div class="line">//issue 3:kCMSampleAttachmentKey_NotSync:没有这个键意味着同步, yes: 异步. no:同步</div><div class="line"> BOOL keyframe = !CFDictionaryContainsKey(dic, kCMSampleAttachmentKey_NotSync); //此代表为同步</div></pre></td></tr></table></figure></p>
<p>而对于<strong>issue 3</strong>从字面意思理解即为以上的说明,但是网上看到很多都是做为查询是否是视频关键帧,而查询文档看到有此关键帧key值<code>kCMSampleBufferAttachmentKey_ForceKeyFrame</code>存在,因此对此值如若有了解情况者敬请告知详情.</p>
<p><strong>5.2 获取CMVideoFormatDesc数据</strong><br>由<a href="https://twenty-zp.gitbooks.io/-/content/san_3001_shi_pin_de_bian_jie_ma.md" target="_blank" rel="external">三、解码篇</a>可知CMVideoFormatDesc 包括编码所用的profile，level，图像的宽和高，deblock滤波器等.具体包含<strong>第一个NALU的SPS</strong>（Sequence Parameter Set）和<strong>第二个NALU的PPS</strong>（Picture Parameter Set）.</p>
<pre><code>//
if (keyframe &amp;&amp; !encoder -&gt; sps) {
    //获取sample buffer 中的 CMVideoFormatDesc
    CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);

    //获取H264参数集合中的SPS和PPS
    const uint8_t * sparameterSet;
    size_t sparameterSetSize,sparameterSetCount ;
   OSStatus statusCode =    CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0);
    if (statusCode == noErr) {
        size_t pparameterSetSize, pparameterSetCount;
        const uint8_t *pparameterSet;
     OSStatus statusCode =    CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0);
        if (statusCode == noErr) {
            encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];
            encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];
        }
    }
}
</code></pre><p><strong>5.3 获取CMBlockBuffer并转换成数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class="line">  size_t  lengthAtOffset,totalLength;</div><div class="line">  char *dataPointer;</div><div class="line">  //接收到的数据展示</div><div class="line">  OSStatus blockBufferStatus = CMBlockBufferGetDataPointer(blockBuffer, 0, &amp;lengthAtOffset, &amp;totalLength, &amp;dataPointer);</div><div class="line">  if (blockBufferStatus != kCMBlockBufferNoErr)</div><div class="line">  &#123;</div><div class="line">      size_t bufferOffset = 0;</div><div class="line">      static const int AVCCHeaderLength = 4;</div><div class="line">      while (bufferOffset &lt; totalLength -  AVCCHeaderLength) &#123;</div><div class="line">          // Read the NAL unit length</div><div class="line">          uint32_t NALUnitLength = 0;</div><div class="line">          /**</div><div class="line">           *  void *memcpy(void *dest, const void *src, size_t n);</div><div class="line">           *  从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</div><div class="line">           */</div><div class="line">          memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</div><div class="line">          //字节从高位反转到低位</div><div class="line">          NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class="line">          </div><div class="line">          RTAVVideoFrame * frame = [RTAVVideoFrame new];</div><div class="line">          frame.sps = encoder -&gt; sps;</div><div class="line">          frame.pps = encoder -&gt; pps;</div><div class="line">          frame.data = [NSData dataWithBytes:(dataPointer+bufferOffset+AVCCHeaderLength) length:NALUnitLength];</div><div class="line">          </div><div class="line">          bufferOffset += NALUnitLength + AVCCHeaderLength;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>此得到的H264数据应用于后面的RTMP协议做推流准备。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/twenty-zp/RealTimeAVVideo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的
    
    </summary>
    
    
      <category term=" - 视频直播系列" scheme="http://blog.img421.com/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>三、视频编解码-解码篇</title>
    <link href="http://blog.img421.com/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/"/>
    <id>http://blog.img421.com/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/</id>
    <published>2016-08-05T02:15:46.000Z</published>
    <updated>2016-08-05T07:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的编解码,占用CPU资源,效率低下,俗称软编解码.而苹果在2014年的iOS8中,开放了VideoToolbox.framwork框架,此框架使用GPU或专用的处理器来进行编解码,俗称硬编解码.而此框架在此之前只有MAC OS系统中可以使用,在iOS作为私有框架.终于苹果在iOS8.0中得到开放引入.</p>
<p>2014年的WWDC<a href="https://developer.apple.com/videos/play/wwdc2014/513/" target="_blank" rel="external">Direct Access to Video Encoding and Decoding</a>中,苹果介绍了使用videoToolbox硬编解码.<br>使用硬编解码有几个优点:</p>
<ul>
<li>提高性能;</li>
<li>增加效率;</li>
<li>延长电量的使用</li>
</ul>
<p>对于编解码,AVFoundation框架只有以下几个功能:</p>
<ol>
<li>直接解压后显示;</li>
<li>直接压缩到一个文件当中;</li>
</ol>
<p>而对于Video Toolbox,我们可以通过以下功能获取到数据,进行网络流传输等多种保存：</p>
<ol>
<li>解压为图像的数据结构;</li>
<li><p>压缩为视频图像的容器数据结构.</p>
<h3 id="一、videoToolbox的基本数据"><a href="#一、videoToolbox的基本数据" class="headerlink" title="一、videoToolbox的基本数据"></a>一、videoToolbox的基本数据</h3><p>Video Toolbox视频编解码前后需要应用的数据结构进行说明。</p>
</li>
<li><p>CVPixelBuffer：编码前和解码后的图像数据结构。此内容包含一系列的CVPixelBufferPool内容</p>
</li>
<li><p>CMTime、CMClock和CMTimebase：时间戳相关。时间以64-bit/32-bit的形式出现。</p>
</li>
<li><p>pixelBufferAttributes:字典设置.可能包括Width/height、pixel format type、• Compatibility (e.g., OpenGL ES, Core Animation)</p>
</li>
<li><p>CMBlockBuffer：编码后，结果图像的数据结构。</p>
</li>
<li><p>CMVideoFormatDescription：图像存储方式，编解码器等格式描述。</p>
</li>
<li><p>(CMSampleBuffer：存放编解码前后的视频图像的容器数据结构。</p>
</li>
<li><p>CMClock </p>
</li>
<li><p>CMTimebase: 关于CMClock的一个控制视图,包含CMClock、时间映射(Time mapping)、速率控制(Rate control)</p>
</li>
</ol>
<hr>
<p>由<a href="er_3001_cai_ji_shi_pin.md">二、采集视频数据</a>可知,我们获取到的数据<code>(CMSampleBufferRef)sampleBuffer</code>为未编码的数据;<br><img src="https://twenty-zp.gitbooks.io/-/content/AFBF71FB-4A38-449B-97FC-EBE4BAC1A3F6.png" alt="图1.1编码前后的数据结构示意图"><br><strong>图1.1</strong><br>上图中,编码前后的视频图像都封装在<code>CMSampleBuffer</code>中,编码前以<code>CVPixelBuffer</code>进行存储;编码后以<code>CMBlockBuffer</code>进行存储。除此之外两者都包括<code>CMTime</code>、<code>CMVideoFormatDesc</code>.</p>
<h3 id="二、获取已编码数据流进行解码展示-获取编码后的数据进行解码展示"><a href="#二、获取已编码数据流进行解码展示-获取编码后的数据进行解码展示" class="headerlink" title="二、获取已编码数据流进行解码展示(获取编码后的数据进行解码展示)"></a>二、获取已编码数据流进行解码展示(获取编码后的数据进行解码展示)</h3><p><img src="https://twenty-zp.gitbooks.io/-/content/6738D208-3D91-4C81-8C09-E9F212FAC080.png" alt="图2.1"><br><strong>图2.1</strong><br>通过网络获取<strong>已编码的H.264数据流</strong>进行<strong>MPEG-4</strong>处理,通过使用<code>AVSampleBufferDisplayLayer</code>解码获取图像显示到设备上。<br><img src="https://twenty-zp.gitbooks.io/-/content/C9B77B4F-5091-4C80-92DE-D84C9AB44D25.png" alt="图2.2 AVSampleBufferDisplayLayer解码显示"><br><strong>图2.2</strong></p>
<p>2.1. 将获取到的<strong>已编码的数据流</strong>进行处理成<code>CMSampleBuffer</code>.<br><img src="https://twenty-zp.gitbooks.io/-/content/DEA65059-66BE-49E3-BF53-5938CB278F36.png" alt="图2.3 处理H.264码流"><br><strong>图2.3</strong><br>由图1.1可知:解码前的图像数据结构$$CMSampleBuffer = CMTime + FormatDesc + CMBlockBuffer$$组成 因此需要从H.264的码流需要以上三个信息组合成<code>CMSampleBuffer</code>.</p>
<blockquote>
<p>H.264码流由一系列的NALU单元组成.NALU单元包含视频图像数据(或视频帧片段)和H.264的参数信息。其中视频图像信息数据是CMBlockBuffer,而H.264参数信息可以组合成FormatDesc,包括编码所用的profile，level，图像的宽和高，deblock滤波器等.具体包含<strong>第一个NALU的SPS</strong>（Sequence Parameter Set）和<strong>第二个NALU的PPS</strong>（Picture Parameter Set）。</p>
</blockquote>
<p><img src="https://twenty-zp.gitbooks.io/-/content/F2D6F4FA-87C1-4B41-9295-6F4E1F8E43C7.png" alt="图2.3 H.264组成结构"><br><strong>图2.4</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* frame的数据可以分为多个slice(片段). </div><div class="line">    * 每个slice中的数据，在帧内预测只用到自己slice的数据， 与其他slice 数据没有依赖关系。 </div><div class="line">    * NAL 是用来将编码的数据进行大包的。 比如，每一个slice 数据可以放在NAL 包中。</div><div class="line">    * I frame 是自己独立编码，不依赖于其他frame 数据。 </div><div class="line">    * P frame 依赖 I frame 数据。 </div><div class="line">    * B frame 依赖 I frame, P frame 或其他 B frame 数据。</div><div class="line">    * H.264码流的第三个NALU是IDR(即时解码器刷新),IDR图像都是I帧，H.264引入IDR图像为了解码的同步,使错</div><div class="line">     误不被传播，当解码器解码到IDR图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，</div><div class="line">     开一个新的序 列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不</div><div class="line">     会使用IDR之前的图像的数据来解码。</div></pre></td></tr></table></figure></p>
<p> <strong>1.1 使用<code>CMVideoFormatDescriptionCreateFromH264ParameterSets</code>提取编码的SPS和PPS压缩转换成<code>MPEG—4</code>需要的SPS和PPS,组合成<code>CMVideoFormatDescription</code></strong><br><img src="https://twenty-zp.gitbooks.io/-/content/9F927C1A-288F-44DF-BB7B-9B5804C55562.png" alt="图2.1.1"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1)每个NALU的开始码是3或4字节头:00 00 01 或 00 00 00 01,按开始码可定位NALU;</div><div class="line">(2)提取出SPS和PPS,通过获取到的编码流,判断开始码后的第一个byte的后5位,7代表SPS,8代表PPS;</div><div class="line">(3)CMVideoFormatDescriptionCreateFromH264ParameterSets函数构建CMVideoFormatDescription.</div></pre></td></tr></table></figure></p>
<p>   <strong>1.2 获取CMBlockBuffer</strong><br>  <img src="https://twenty-zp.gitbooks.io/-/content/FCACB659-4B39-4497-BDF4-246499F94EAC.png" alt="图2.1.2"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1)通过开始码,定位到NALU;</div><div class="line">(2)确认类型数据将开始码替换为NALU的长度信息（4 Byte）</div><div class="line">(3)通过CMBlockBufferCreateWithMemoryBlock接口构造CMBlockBufferRef</div></pre></td></tr></table></figure></p>
<p>   <strong>1.3 添加CMTime</strong><br>  <img src="https://twenty-zp.gitbooks.io/-/content/BAC15B30-4D58-4ECD-A3EF-C924F61759F4.png" alt="图2.5"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/twenty-zp/RealTimeAVVideo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的
    
    </summary>
    
    
      <category term=" - 视频直播系列" scheme="http://blog.img421.com/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二、采集视频数据</title>
    <link href="http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/"/>
    <id>http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/</id>
    <published>2016-08-05T02:15:08.000Z</published>
    <updated>2016-08-05T07:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>苹果对于音视频的采集已经提供给我们很好的封装:AVFoundation.framework.我们可以使用AVFoundation框架来采集视频数据.<br><img src="https://twenty-zp.gitbooks.io/-/content/AVCaptureSession.svg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">@interface RTAVVideoCaputre ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;</div><div class="line">&#123;</div><div class="line">    AVCaptureVideoPreviewLayer * _preViewLayer;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">@property (nonatomic,strong)AVCaptureSession *session;</div><div class="line">@property (nonatomic,strong)RTAVVideoConfiguration *videoConfiguration;</div><div class="line">@end</div><div class="line">@implementation RTAVVideoCaputre</div><div class="line"></div><div class="line">- (instancetype)initWithVideoConfiguration:(RTAVVideoConfiguration *)configuration</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _videoConfiguration = configuration;</div><div class="line">        [self addPreVideo];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#pragma mark - Method</div><div class="line">- (void)addPreVideo</div><div class="line">&#123;</div><div class="line">    AVCaptureVideoPreviewLayer * preViewLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.session];</div><div class="line">    preViewLayer.frame = [UIScreen mainScreen].bounds;</div><div class="line">    preViewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;</div><div class="line">    </div><div class="line">    _preViewLayer = preViewLayer;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - delegate</div><div class="line"></div><div class="line">#pragma mark AVCaptureSessionDelegete</div><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class="line">&#123;</div><div class="line">    CVImageBufferRef imageBuffer  = CMSampleBufferGetImageBuffer(sampleBuffer);</div><div class="line">    if (imageBuffer != NULL) &#123;</div><div class="line">        if ([_delegate respondsToSelector:@selector(captureOutput:pixelBuffer:)]) &#123;</div><div class="line">            [_delegate captureOutput:self pixelBuffer:imageBuffer];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#pragma mark - setter &amp; getter</div><div class="line">- (AVCaptureSession *)session</div><div class="line">&#123;</div><div class="line">    if (!_session) &#123;</div><div class="line">        //4.</div><div class="line">        AVCaptureSession * session = [[AVCaptureSession alloc]init];</div><div class="line">        session.sessionPreset = _videoConfiguration.avsessionPreset;</div><div class="line">        //1.</div><div class="line">        AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">        </div><div class="line">        NSError * error = nil;</div><div class="line">        //2.</div><div class="line">        AVCaptureDeviceInput * videoInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];</div><div class="line">      </div><div class="line">        //3.</div><div class="line">        AVCaptureVideoDataOutput *  videoOutput = [[AVCaptureVideoDataOutput alloc]init];</div><div class="line">        dispatch_queue_t videoDataOutputQueue = dispatch_queue_create(&quot;VideoDataOutputQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">        [videoOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];</div><div class="line">        </div><div class="line">        [videoOutput connectionWithMediaType:AVMediaTypeVideo] ;</div><div class="line">        </div><div class="line">        videoOutput.videoSettings = @&#123;(id)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_32BGRA)&#125;;</div><div class="line">        </div><div class="line">        //设置帧率</div><div class="line">        if ([device respondsToSelector:@selector(setActiveVideoMaxFrameDuration:)] &amp;&amp; [device respondsToSelector:@selector(setActiveVideoMinFrameDuration:)]) &#123;</div><div class="line">            NSError * error ;</div><div class="line">            [device lockForConfiguration:&amp;error];</div><div class="line">            if (nil == error) &#123;</div><div class="line">#if defined (__IPHONE_7_0)</div><div class="line">                device.activeVideoMaxFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoFrameRate);</div><div class="line">                device.activeVideoMinFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoFrameRate);</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line">            [device unlockForConfiguration];</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            for (AVCaptureConnection * connection in videoOutput.connections) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">                if ([connection respondsToSelector:@selector(setVideoMinFrameDuration:)])</div><div class="line">                    connection.videoMinFrameDuration = CMTimeMake(1,  (int32_t)_videoConfiguration.videoMinFrameRate);</div><div class="line">                </div><div class="line">                if ([connection respondsToSelector:@selector(setVideoMaxFrameDuration:)])</div><div class="line">                    connection.videoMaxFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoMaxFrameRate);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        //5.</div><div class="line">        if ([session canAddInput:videoInput]) &#123;</div><div class="line">            [session addInput:videoInput];</div><div class="line">        &#125;</div><div class="line">        if ([session canAddOutput:videoOutput]) &#123;</div><div class="line">            [session addOutput:videoOutput];</div><div class="line">        &#125;</div><div class="line">        _session = session;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return _session;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1.通过获取系统支持有效的设备类型–视频类型;</p>
<p>2.设置作为捕捉视频的输入设备;</p>
<p>3.设置捕捉数据的输出,通过代理方法(7)获取处理<strong>未编解码的帧数据sampleBuffer;</strong></p>
<p>4.每一个实时的捕获,全部通过一个session(会话)来开启;</p>
<p>5.将输入设备和输出设备添加到会话中;</p>
<p>6.开启会话捕获.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/twenty-zp/RealTimeAVVideo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;苹果对于音视频的采集已经提供给我们很好的封装:AVFoundati
    
    </summary>
    
    
      <category term=" - 视频直播系列" scheme="http://blog.img421.com/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>一、音视频配置文档概念</title>
    <link href="http://blog.img421.com/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/"/>
    <id>http://blog.img421.com/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/</id>
    <published>2016-08-05T02:12:30.000Z</published>
    <updated>2016-08-05T08:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始中我们要了解几种影响音视频的质量的关键概念:</p>
<ol>
<li><p><strong>码流</strong>(也通常称码率、比特率),指在单位时间传输或解码的位数(数据流量),是视频中画面质量控制的最重要部分。在分辨率相同的情况下,码流越大,压缩的比例就越小,画面质量越高,视频文件的体积也就越大.码流越大,说明单位时间内采样率越大,数据流和精度也越高,所以图像画面质量越好、越清晰,但要求设备的解码能力也越强;</p>
</li>
<li><p><strong>采样率</strong>(也称为采样速度或采样频率),指每秒从连续的信号中提取并组成离散信号的采样个数,使用Hz(赫兹)来表示。 能够将模拟信号转换成数字信号时的采样频率,也就是单位时间内采样多少点。一个采样点数据有多少个比特。采集的数值越大,音视频的质量越好。</p>
</li>
<li><p><strong>比特率</strong>,指每秒传送的比特数,单位我bps(Bit Per Second),比特率越大,输送的数据也就越大,音质越好.视频中的比特率通常为码率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">比特率 =采样率 * 采用位数 *声道数.</div></pre></td></tr></table></figure>
</li>
<li><p><strong>帧速度</strong>(帧率),指每秒刷新图片的帧数(FPS),帧数越多,图像动作越流畅.</p>
</li>
<li><p><strong>分辨率</strong>,即为帧的大小.每一帧都是一副图像。一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。<br>计算输出文件大小公式：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">音频编码率（KBit为单位）/8 +视频编码率（KBit为单位）/8 *影片总长度（秒为单位）</div><div class="line">=文件大小（MB为单位）</div></pre></td></tr></table></figure>
<h5 id="由此从上述概念可知"><a href="#由此从上述概念可知" class="headerlink" title="由此从上述概念可知:"></a>由此从上述概念可知:</h5><p><em>码流</em>、<em>采样率</em>、<em>帧率</em>值越大,视频和音频的质量和清晰度越大.分辨率影响图像大小,所以分辨率越高,图像越大,分辨率越低,图像越小。</p>
<p>因此,码率一定的情况下,分辨率越高,图像越不清晰.</p>
<p>但事实情况下,硬件设备也会影响,我们不能无限制的让这些参数变大,同时，码率一定的情况下,分辨率在一定的范围内取值图像都是清晰的;同样分辨率一定,码率在一定的范围内取值也都是清晰。<br><img src="https://twenty-zp.gitbooks.io/-/content/adcaae0535cc795cb6eb0ee1b179790d.jpg" alt="网络图片"></p>
<p>以上标准参考来自网络</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始中我们要了解几种影响音视频的质量的关键概念:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;码流&lt;/strong&gt;(也通常称码率、比特率),指在单位时间传输或解码的位数(数据流量),是视频中画面质量控制的最重要部分。在分辨率相同的情况下,码流越大,压缩的比例就越小,画
    
    </summary>
    
    
      <category term=" - 视频直播系列" scheme="http://blog.img421.com/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>iOS视频直播系列</title>
    <link href="http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/"/>
    <id>http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/</id>
    <published>2016-08-05T02:08:10.000Z</published>
    <updated>2016-08-05T08:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本教程为是一个系列教程.从0开始带你装逼,带你飞.(开玩笑,大家共同进步^_^).如若有什么不对请指点。</p>
<p><a href="https://www.gitbook.com/book/twenty-zp/-/details" target="_blank" rel="external">内容全地址</a></p>
<p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>文章从视频和音频两部分讲起。追寻以下图录流程。<br><img src="https://twenty-zp.gitbooks.io/-/content/69ABD544-ECDA-4A8D-A4BE-250D62D896E5.png" alt="导图"></p>
<p><a href="http://blog.img421.com/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/">一、音视频配置文档概念</a></p>
<p><a href="http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/">二、采集视频数据</a></p>
<p><a href="http://blog.img421.com/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/">三、视频编解码-解码篇</a></p>
<p><a href="http://blog.img421.com/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/">四、视频的编解码-编码篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程为是一个系列教程.从0开始带你装逼,带你飞.(开玩笑,大家共同进步^_^).如若有什么不对请指点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gitbook.com/book/twenty-zp/-/details&quot; target=&quot;_blank&quot; re
    
    </summary>
    
    
      <category term=" - 视频直播系列" scheme="http://blog.img421.com/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>当NSDictionary遇到nil</title>
    <link href="http://blog.img421.com/2016/07/11/dang-nsdictionaryyu-dao-nil/"/>
    <id>http://blog.img421.com/2016/07/11/dang-nsdictionaryyu-dao-nil/</id>
    <published>2016-07-11T08:15:48.000Z</published>
    <updated>2016-08-01T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>#问题<br>在开发中我们经常会遇到如下问题：</p>
<ul>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[1]”</li>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> setObjectForKey: object cannot be nil (key: no_nillKey)”</li>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> setObjectForKey: key cannot be nil”</li>
</ul>
<p>由上可知,Objective-C里的<strong>NSDictionary</strong>是不支持<strong>nil</strong>作为key和value的.但是总会有一些地方我们往往会不注意的插入<strong>nil</strong>值。</p>
<p>通过我们的做法是：</p>
<ol>
<li><p>使用<strong>if</strong>判断对象是否存在:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (obj) &#123;</div><div class="line">	[dic setObject:obj forKey:@&quot;obj&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>三目运算符</strong>来判断</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[dic setObject:obj?:@&quot;&quot; forKey:@&quot;obj&quot;];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做有几个坏处：</p>
<ol>
<li>代码冗余较多；</li>
<li>如果忘了检查<strong>nil</strong>,在某些情况下就会遇到以上问题;</li>
<li>后台的API大部分是以JSON 格式传递,所以一个<strong>nil</strong>值不论是传空字符还是不传都不是很正确。</li>
</ol>
<p>因此我们希望<strong>NSDictionary</strong>用起来会遇到以下几种情况:</p>
<ol>
<li><p>插入<strong>nil</strong>时不会crash</p>
</li>
<li><p>插入<strong>nil</strong>值以后(不管是<strong>key</strong>为nil还是<strong>value</strong>为nil)对应的key-value 都不包含在<strong>NSDictionary</strong>中</p>
</li>
</ol>
<p>#设计<br>根据crash 可以看出,dictionary有三个主要的入口传入nil 对象：</p>
<ol>
<li>字面量一个dictionary的时候，会调用<strong>dictionaryWithObjects:forKeys:count:</strong></li>
<li>直接调用<strong>setObjectForKey:</strong>的时候</li>
<li>通过下标方式赋值的时候(key不能为nil)调用”<strong>setObjectForKey: key cannot be nil”</strong></li>
</ol>
<p>当使用 <strong>setObjectForKey</strong>时对象是<strong>__NSDictionaryM</strong>类,同样要定义此类。<br>因此可以通过Method Swizzing 把这几种方法替换为自己的方法,在key或value 为<strong>nil</strong>的时候,并不加入到NSDictionary中.</p>
<p>以<strong>dictionaryWithObjects:forKeys:count</strong>为例:</p>
<p>创建交换方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  NSDictionary+SafeNil.m</div><div class="line">//  当NSDictionary遇到nil</div><div class="line">//</div><div class="line">//  Created by iLogiEMAC on 16/7/11.</div><div class="line">//  Copyright © 2016年 zp. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;NSDictionary+SafeNil.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation NSObject (SafeNil)</div><div class="line"></div><div class="line">+ (BOOL)swizzing_method:(SEL)originalSelector  replaceMethod:(SEL)replaceSelector</div><div class="line">&#123;</div><div class="line">    Method original = class_getInstanceMethod(self, originalSelector);</div><div class="line">    Method replace = class_getInstanceMethod(self, replaceSelector);</div><div class="line">    if (!original || !replace) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    class_addMethod(self, originalSelector, class_getMethodImplementation(self, originalSelector), method_getTypeEncoding(original));</div><div class="line">    class_addMethod(self, replaceSelector, class_getMethodImplementation(self, replaceSelector), method_getTypeEncoding(replace));</div><div class="line">    </div><div class="line">    method_exchangeImplementations(original, replace);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)swizzingClassMethod:(SEL)originSelector replaceMethod:(SEL)replaceSelector</div><div class="line">&#123;</div><div class="line">    return [object_getClass((id)self) swizzing_method:originSelector replaceMethod:replaceSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>实现自定义的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">@implementation NSDictionary (SafeNil)</div><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        [self swizzingClassMethod:@selector(initWithObjects:forKeys:count:) replaceMethod:@selector(zpSwizzing_initWithObjects:forKeys:count:)];</div><div class="line">        [self swizzingClassMethod:@selector(dictionaryWithObjects:forKeys:count:) replaceMethod:@selector(zpSwizzingClass_dictionaryWithObjects:forKeys:count:)];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)zpSwizzing_initWithObjects:(const id  _Nonnull __unsafe_unretained *)objects forKeys:(const id&lt;NSCopying&gt;  _Nonnull __unsafe_unretained *)keys count:(NSUInteger)cnt&#123;</div><div class="line">    id safeObjects[cnt];</div><div class="line">    id safeKeys[cnt];</div><div class="line">    </div><div class="line">    NSUInteger j = 0;</div><div class="line">    for (NSUInteger i = 0; i &lt; cnt ; i++) &#123;</div><div class="line">        id key = keys[i];</div><div class="line">        id obj = objects[i];</div><div class="line">        if (!key || !obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        safeObjects[j] = obj;</div><div class="line">        safeKeys[j] = key;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    return  [self zpSwizzing_initWithObjects:safeObjects forKeys:safeKeys count:j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (instancetype)zpSwizzingClass_dictionaryWithObjects:(const id  _Nonnull __unsafe_unretained *)objects forKeys:(const id&lt;NSCopying&gt;  _Nonnull __unsafe_unretained *)keys count:(NSUInteger)cnt</div><div class="line">&#123;</div><div class="line">    id safeObjects[cnt];</div><div class="line">    id safeKeys[cnt];</div><div class="line">    </div><div class="line">    NSUInteger j = 0;</div><div class="line">    for (NSUInteger i = 0; i &lt; cnt ; i++) &#123;</div><div class="line">        id key = keys[i];</div><div class="line">        id obj = objects[i];</div><div class="line">        if (!key || !obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        safeObjects[j] = obj;</div><div class="line">        safeKeys[j] = key;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    return [self zpSwizzingClass_dictionaryWithObjects:safeObjects forKeys:safeKeys count:j];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在单元测试中测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSString * no_nillKey = @&quot;no_nillKey&quot;;</div><div class="line">NSString * nilKey = nil;</div><div class="line">NSString * no_nillValue = @&quot;no_nillValue&quot;;</div><div class="line">NSString * nilValue = nil;</div><div class="line">NSDictionary * dic = @&#123;</div><div class="line">                       no_nillKey: nilValue,</div><div class="line">                       nilKey: no_nillValue</div><div class="line">&#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,dic);</div><div class="line">     </div><div class="line">dic 输出为 &#123; &#125;</div></pre></td></tr></table></figure>
<p><a href="http://tech.glowing.com/cn/how-we-made-nsdictionary-nil-safe/" target="_blank" rel="external">参考地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#问题&lt;br&gt;在开发中我们经常会遇到如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;failed: caught “NSInvalidArgumentException”, “&lt;em&gt;*&lt;/em&gt; -[__NSPlaceholderDictionary initWithObjects
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用interactivePopGestureRecognizer卡住的问题-不是BUG的BUG</title>
    <link href="http://blog.img421.com/2016/06/08/shi-yong-interactivepopgesturerecognizerqia-zhu-de-wen-ti-bu-shi-bugde-bug/"/>
    <id>http://blog.img421.com/2016/06/08/shi-yong-interactivepopgesturerecognizerqia-zhu-de-wen-ti-bu-shi-bugde-bug/</id>
    <published>2016-06-08T02:29:23.000Z</published>
    <updated>2016-06-08T02:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>   记录一次小问题</p>
</blockquote>
<p>苹果在iOS7的<strong>UINavigationController</strong>中加入了一个返回手势–<strong>interactivePopGestureRecognizer</strong>,因此支持iOS7以上版本,不用自己去实现一个手势去操作.<br>在iOS开发中,对于有些单独的一个<strong>ViewController</strong>页面等控制习惯性的喜欢在<strong>viewWillAppear</strong>生命周期方法中设置,因此在设置<strong>self.navigationController的interactivePopGestureRecognizer</strong>属性禁用系统时也会这样做.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillAppear:animated];    </div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为只有此单独一个页面禁用系统的手势返回,所以要让此<strong>ViewController</strong>自己去启动<strong>interactivePopGestureRecognizer</strong>. 在<strong>viewWillDisappear</strong>方法中去实现启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试的时候,当由<strong>ViewController</strong>通过<strong>push</strong>方法导航到下一个页面,然后执行手势返回的时候会发生页面卡住,但是按住<strong>Home键</strong>到后台,然后重新回到<strong>app</strong>确实可以返回到上一页面.</p>
<p>通过操作检查,当我们开始使用手势返回的时候,在执行<strong>interactivePopGestureRecognizer</strong>手势方法<strong>action=handleNavigationTransition:</strong> 时就开始执行上一个页面的<strong>viewWillAppear</strong>方法,而因此我在<strong>viewWillAppear</strong>方法中禁用了<strong>interactivePopGestureRecognizer</strong>返回手势,因此当前页面并没有看到<strong>pop</strong>动画,但确实是返回到上一页面.由此修改内容我们可以在<strong><em>viewDidAppear</em></strong>中,当页面已经显示的时候将方法禁用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   记录一次小问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;苹果在iOS7的&lt;strong&gt;UINavigationController&lt;/strong&gt;中加入了一个返回手势–&lt;strong&gt;interactivePopGestureRecog
    
    </summary>
    
    
  </entry>
  
</feed>
