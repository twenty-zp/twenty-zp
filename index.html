<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="你只有一定要,才一定会得到">
<meta property="og:type" content="website">
<meta property="og:title" content="Twenty's 时间念">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Twenty's 时间念">
<meta property="og:description" content="你只有一定要,才一定会得到">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Twenty's 时间念">
<meta name="twitter:description" content="你只有一定要,才一定会得到">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Twenty's 时间念 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a19dd0c033f48c51a16dc7871acded18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Twenty's 时间念</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/" itemprop="url">
                  四、视频的编解码-编码篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:21:42+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的编解码,占用CPU资源,效率低下,俗称软编解码.而苹果在2014年的iOS8中,开放了VideoToolbox.framwork框架,此框架使用GPU或专用的处理器来进行编解码,俗称硬编解码.而此框架在此之前只有MAC OS系统中可以使用,在iOS作为私有框架.终于苹果在iOS8.0中得到开放引入.</p>
<p>2014年的WWDC<a href="https://developer.apple.com/videos/play/wwdc2014/513/" target="_blank" rel="external">Direct Access to Video Encoding and Decoding</a>中,苹果介绍了使用videoToolbox硬编解码.<br>使用硬编解码有几个优点:</p>
<ul>
<li>提高性能;</li>
<li>增加效率;</li>
<li>延长电量的使用</li>
</ul>
<p>对于编解码,AVFoundation框架只有以下几个功能:</p>
<ol>
<li>直接解压后显示;</li>
<li>直接压缩到一个文件当中;</li>
</ol>
<p>而对于Video Toolbox,我们可以通过以下功能获取到数据,进行网络流传输等多种保存：</p>
<ol>
<li>解压为图像的数据结构;</li>
<li><p>压缩为视频图像的容器数据结构.<br>##一、videoToolbox的基本数据<br>Video Toolbox视频编解码前后需要应用的数据结构进行说明。</p>
</li>
<li><p>CVPixelBuffer：编码前和解码后的图像数据结构。此内容包含一系列的CVPixelBufferPool内容</p>
</li>
<li><p>CMTime、CMClock和CMTimebase：时间戳相关。时间以64-bit/32-bit的形式出现。</p>
</li>
<li><p>pixelBufferAttributes:字典设置.可能包括Width/height、pixel format type、• Compatibility (e.g., OpenGL ES, Core Animation)</p>
</li>
<li><p>CMBlockBuffer：编码后，结果图像的数据结构。</p>
</li>
<li><p>CMVideoFormatDescription：图像存储方式，编解码器等格式描述。</p>
</li>
<li><p>(CMSampleBuffer：存放编解码前后的视频图像的容器数据结构。</p>
</li>
<li><p>CMClock </p>
</li>
<li><p>CMTimebase: 关于CMClock的一个控制视图,包含CMClock、时间映射(Time mapping)、速率控制(Rate control)</p>
</li>
</ol>
<hr>
<p>由<a href="er_3001_cai_ji_shi_pin.md">二、采集视频数据</a>可知,我们获取到的数据<code>(CMSampleBufferRef)sampleBuffer</code>为未编码的数据;</p>
<p><img src="https://twenty-zp.gitbooks.io/-/content/AFBF71FB-4A38-449B-97FC-EBE4BAC1A3F6.png" alt="图1.1编码前后的数据结构示意图"><strong>图1.1</strong></p>
<p>上图中,编码前后的视频图像都封装在<code>CMSampleBuffer</code>中,编码前以<code>CVPixelBuffer</code>进行存储;编码后以<code>CMBlockBuffer</code>进行存储。除此之外两者都包括<code>CMTime</code>、<code>CMVideoFormatDesc</code>.</p>
<p>##二、视频数据流编码并上传到服务器<br><img src="https://twenty-zp.gitbooks.io/-/content/4218AA54-612D-4C96-92D6-1DC9E6358142.png" alt="图2.1"></p>
<p>###1.将CVPixelBuffer使用VTCompressionSession进行数据流的硬编码。</p>
<p>####(1)初始化VTCompressionSession</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">VT_EXPORT OSStatus </div><div class="line">VTCompressionSessionCreate(</div><div class="line">	CM_NULLABLE CFAllocatorRef							allocator,</div><div class="line">	int32_t												width,</div><div class="line">	int32_t												height,</div><div class="line">	CMVideoCodecType									codecType,</div><div class="line">	CM_NULLABLE CFDictionaryRef							encoderSpecification,</div><div class="line">	CM_NULLABLE CFDictionaryRef							sourceImageBufferAttributes,</div><div class="line">	CM_NULLABLE CFAllocatorRef							compressedDataAllocator,</div><div class="line">	CM_NULLABLE VTCompressionOutputCallback				outputCallback,</div><div class="line">	void * CM_NULLABLE									outputCallbackRefCon,</div><div class="line">	CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef * CM_NONNULL compressionSessionOut)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_8_0);</div></pre></td></tr></table></figure>
<blockquote>
<p>VTCompressionSession的初始化参数说明:</p>
</blockquote>
<ul>
<li>allocator:分配器,设置NULL为默认分配</li>
<li>width: 宽</li>
<li>height: 高</li>
<li>codecType: 编码类型,如kCMVideoCodecType_H264</li>
<li>encoderSpecification: 编码规范。设置NULL由videoToolbox自己选择</li>
<li>sourceImageBufferAttributes: 源像素缓冲区属性.设置NULL不让videToolbox创建,而自己创建</li>
<li>compressedDataAllocator: 压缩数据分配器.设置NULL,默认的分配</li>
<li>outputCallback: 当VTCompressionSessionEncodeFrame被调用压缩一次后会被异步调用.<strong>注:当你设置NULL的时候,你需要调用VTCompressionSessionEncodeFrameWithOutputHandler方法进行压缩帧处理,支持iOS9.0以上</strong></li>
<li>outputCallbackRefCon: 回调客户定义的参考值.</li>
<li>compressionSessionOut: 压缩会话变量。</li>
</ul>
<p>####(2)配置VTCompressionSession<br>  使用VTSessionSetProperty()调用进行配置compression。<br>  <img src="https://twenty-zp.gitbooks.io/-/content/3EFF1058-1A5B-45E9-B7F3-21BA58C232F2.png" alt=""></p>
<ul>
<li>kVTCompressionPropertyKey_AllowFrameReordering: 允许帧重新排序.默认为true</li>
<li>kVTCompressionPropertyKey_AverageBitRate: 设置需要的平均编码率</li>
<li>kVTCompressionPropertyKey_H264EntropyMode：H264的<a href="http://baike.baidu.com/view/182718.htm" target="_blank" rel="external">熵编码</a>模式。有两种模式:一种基于上下文的二进制算数编码CABAC和可变长编码VLC.在slice层之上（picture和sequence）使用定长或变长的二进制编码，slice层及其以下使用VLC或CABAC.<a href="http://www.programgo.com/article/71134070443/" target="_blank" rel="external">详情请参考</a></li>
<li>kVTCompressionPropertyKey_RealTime: 视频编码压缩是否是实时压缩。可设置CFBoolean或NULL.默认为NULL</li>
<li>kVTCompressionPropertyKey_ProfileLevel: 对于编码流指定配置和标准 .比如kVTProfileLevel_H264_Main_AutoLevel</li>
</ul>
<p>配置过VTCompressionSession后,可以可选的调用<code>VTCompressionSessionPrepareToEncodeFrames</code>进行准备工作编码帧。</p>
<p>####(3)开始硬编码流入的数据<br>使用<code>VTCompressionSessionEncodeFrame</code>方法进行编码.当编码结束后调用outputCallback回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VT_EXPORT OSStatus</div><div class="line">VTCompressionSessionEncodeFrame(</div><div class="line">	CM_NONNULL VTCompressionSessionRef	session,</div><div class="line">	CM_NONNULL CVImageBufferRef			imageBuffer,</div><div class="line">	CMTime								presentationTimeStamp,</div><div class="line">	CMTime								duration, // may be kCMTimeInvalid</div><div class="line">	CM_NULLABLE CFDictionaryRef			frameProperties,</div><div class="line">	void * CM_NULLABLE					sourceFrameRefCon,</div><div class="line">	VTEncodeInfoFlags * CM_NULLABLE		infoFlagsOut )</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_8_0);</div></pre></td></tr></table></figure>
<ul>
<li>presentationTimeStamp： 获取到的这个sample buffer数据的展示时间戳。每一个传给这个session的时间戳都要大于前一个展示时间戳.</li>
<li>duration: 对于获取到sample buffer数据,这个帧的展示时间.如果没有时间信息,可设置<code>kCMTimeInvalid</code>.</li>
<li>frameProperties: 包含这个帧的属性.帧的改变会影响后边的编码帧.</li>
<li>sourceFrameRefCon: 回调函数会引用你设置的这个帧的参考值.</li>
<li>infoFlagsOut: 指向一个<code>VTEncodeInfoFlags</code>来接受一个编码操作.如果使用异步运行,<code>kVTEncodeInfo_Asynchronous</code>被设置；同步运行,<code>kVTEncodeInfo_FrameDropped</code>被设置；设置NULL为不想接受这个信息.</li>
</ul>
<p>####(4)执行VTCompressionOutputCallback回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef void (*VTCompressionOutputCallback)(</div><div class="line">		void * CM_NULLABLE outputCallbackRefCon,</div><div class="line">		void * CM_NULLABLE sourceFrameRefCon, </div><div class="line">		OSStatus status, </div><div class="line">		VTEncodeInfoFlags infoFlags,</div><div class="line">		CM_NULLABLE CMSampleBufferRef sampleBuffer );</div></pre></td></tr></table></figure>
<ul>
<li>outputCallbackRefCon: 回调函数的参考值</li>
<li>sourceFrameRefCon: VTCompressionSessionEncodeFrame函数中设置的帧的参考值</li>
<li>status: 压缩的成功为noErr,如失败有错误码</li>
<li>infoFlags: 包含编码操作的信息标识</li>
<li>sampleBuffer: 如果压缩成功或者帧不丢失,则包含这个已压缩的数据CMSampleBuffer,否则为NULL</li>
</ul>
<p>####(5)将压缩成功的sampleBuffer数据进行处理为基本流NSData上传到服务器</p>
<blockquote>
<p>MPEG-4是一套用于音频、视频信息的压缩编码标准.</p>
</blockquote>
<p><img src="https://twenty-zp.gitbooks.io/-/content/9C31AACA-9BFA-4434-89DD-BFD4787F4038.png" alt="图5.1"><br>由<strong>图1.1</strong>可知,已压缩 $$CMSampleBuffer = CMTime(可选) + CMBlockBuffer + CMVideoFormatDesc$$。</p>
<p><strong>5.1 先判断压缩的数据是否正确</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//不存在则代表压缩不成功或帧丢失</div><div class="line"> if(!sampleBuffer) return;</div><div class="line"> if (status != noErr) return;</div><div class="line"> //返回sampleBuffer中包括可变字典的不可变数组,如果有错误则为NULL</div><div class="line">CFArrayRef  array =  CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true);</div><div class="line"> if (!array)  return;</div><div class="line"></div><div class="line">CFDictionaryRef dic = CFArrayGetValueAtIndex(array, 0);</div><div class="line"> if (!dic) return;</div><div class="line"> </div><div class="line">//issue 3:kCMSampleAttachmentKey_NotSync:没有这个键意味着同步, yes: 异步. no:同步</div><div class="line"> BOOL keyframe = !CFDictionaryContainsKey(dic, kCMSampleAttachmentKey_NotSync); //此代表为同步</div></pre></td></tr></table></figure></p>
<p>而对于<strong>issue 3</strong>从字面意思理解即为以上的说明,但是网上看到很多都是做为查询是否是视频关键帧,而查询文档看到有此关键帧key值<code>kCMSampleBufferAttachmentKey_ForceKeyFrame</code>存在,因此对此值如若有了解情况者敬请告知详情.</p>
<p><strong>5.2 获取CMVideoFormatDesc数据</strong><br>由<a href="https://twenty-zp.gitbooks.io/-/content/san_3001_shi_pin_de_bian_jie_ma.md" target="_blank" rel="external">三、解码篇</a>可知CMVideoFormatDesc 包括编码所用的profile，level，图像的宽和高，deblock滤波器等.具体包含<strong>第一个NALU的SPS</strong>（Sequence Parameter Set）和<strong>第二个NALU的PPS</strong>（Picture Parameter Set）.</p>
<pre><code>//
if (keyframe &amp;&amp; !encoder -&gt; sps) {
    //获取sample buffer 中的 CMVideoFormatDesc
    CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);

    //获取H264参数集合中的SPS和PPS
    const uint8_t * sparameterSet;
    size_t sparameterSetSize,sparameterSetCount ;
   OSStatus statusCode =    CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0);
    if (statusCode == noErr) {
        size_t pparameterSetSize, pparameterSetCount;
        const uint8_t *pparameterSet;
     OSStatus statusCode =    CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0);
        if (statusCode == noErr) {
            encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];
            encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];
        }
    }
}
</code></pre><p><strong>5.3 获取CMBlockBuffer并转换成数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class="line">  size_t  lengthAtOffset,totalLength;</div><div class="line">  char *dataPointer;</div><div class="line">  //接收到的数据展示</div><div class="line">  OSStatus blockBufferStatus = CMBlockBufferGetDataPointer(blockBuffer, 0, &amp;lengthAtOffset, &amp;totalLength, &amp;dataPointer);</div><div class="line">  if (blockBufferStatus != kCMBlockBufferNoErr)</div><div class="line">  &#123;</div><div class="line">      size_t bufferOffset = 0;</div><div class="line">      static const int AVCCHeaderLength = 4;</div><div class="line">      while (bufferOffset &lt; totalLength -  AVCCHeaderLength) &#123;</div><div class="line">          // Read the NAL unit length</div><div class="line">          uint32_t NALUnitLength = 0;</div><div class="line">          /**</div><div class="line">           *  void *memcpy(void *dest, const void *src, size_t n);</div><div class="line">           *  从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</div><div class="line">           */</div><div class="line">          memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</div><div class="line">          //字节从高位反转到低位</div><div class="line">          NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class="line">          </div><div class="line">          RTAVVideoFrame * frame = [RTAVVideoFrame new];</div><div class="line">          frame.sps = encoder -&gt; sps;</div><div class="line">          frame.pps = encoder -&gt; pps;</div><div class="line">          frame.data = [NSData dataWithBytes:(dataPointer+bufferOffset+AVCCHeaderLength) length:NALUnitLength];</div><div class="line">          </div><div class="line">          bufferOffset += NALUnitLength + AVCCHeaderLength;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>此得到的H264数据应用于后面的RTMP协议做推流准备。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/" itemprop="url">
                  三、视频编解码-解码篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:15:46+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>在此之前我们通常使用的FFmpeg多媒体库,利用CPU来进行视频的编解码,占用CPU资源,效率低下,俗称软编解码.而苹果在2014年的iOS8中,开放了VideoToolbox.framwork框架,此框架使用GPU或专用的处理器来进行编解码,俗称硬编解码.而此框架在此之前只有MAC OS系统中可以使用,在iOS作为私有框架.终于苹果在iOS8.0中得到开放引入.</p>
<p>2014年的WWDC<a href="https://developer.apple.com/videos/play/wwdc2014/513/" target="_blank" rel="external">Direct Access to Video Encoding and Decoding</a>中,苹果介绍了使用videoToolbox硬编解码.<br>使用硬编解码有几个优点:</p>
<ul>
<li>提高性能;</li>
<li>增加效率;</li>
<li>延长电量的使用</li>
</ul>
<p>对于编解码,AVFoundation框架只有以下几个功能:</p>
<ol>
<li>直接解压后显示;</li>
<li>直接压缩到一个文件当中;</li>
</ol>
<p>而对于Video Toolbox,我们可以通过以下功能获取到数据,进行网络流传输等多种保存：</p>
<ol>
<li>解压为图像的数据结构;</li>
<li><p>压缩为视频图像的容器数据结构.<br>###一、videoToolbox的基本数据<br>Video Toolbox视频编解码前后需要应用的数据结构进行说明。</p>
</li>
<li><p>CVPixelBuffer：编码前和解码后的图像数据结构。此内容包含一系列的CVPixelBufferPool内容</p>
</li>
<li><p>CMTime、CMClock和CMTimebase：时间戳相关。时间以64-bit/32-bit的形式出现。</p>
</li>
<li><p>pixelBufferAttributes:字典设置.可能包括Width/height、pixel format type、• Compatibility (e.g., OpenGL ES, Core Animation)</p>
</li>
<li><p>CMBlockBuffer：编码后，结果图像的数据结构。</p>
</li>
<li><p>CMVideoFormatDescription：图像存储方式，编解码器等格式描述。</p>
</li>
<li><p>(CMSampleBuffer：存放编解码前后的视频图像的容器数据结构。</p>
</li>
<li><p>CMClock </p>
</li>
<li><p>CMTimebase: 关于CMClock的一个控制视图,包含CMClock、时间映射(Time mapping)、速率控制(Rate control)</p>
</li>
</ol>
<hr>
<p>由<a href="er_3001_cai_ji_shi_pin.md">二、采集视频数据</a>可知,我们获取到的数据<code>(CMSampleBufferRef)sampleBuffer</code>为未编码的数据;</p>
<p><img src="https://twenty-zp.gitbooks.io/-/content/AFBF71FB-4A38-449B-97FC-EBE4BAC1A3F6.png" alt="图1.1编码前后的数据结构示意图"><strong>图1.1</strong></p>
<p>上图中,编码前后的视频图像都封装在<code>CMSampleBuffer</code>中,编码前以<code>CVPixelBuffer</code>进行存储;编码后以<code>CMBlockBuffer</code>进行存储。除此之外两者都包括<code>CMTime</code>、<code>CMVideoFormatDesc</code>.</p>
<p>###二、获取已编码数据流进行解码展示(获取编码后的数据进行解码展示)<br><img src="https://twenty-zp.gitbooks.io/-/content/6738D208-3D91-4C81-8C09-E9F212FAC080.png" alt="图2.1"><strong>图2.1</strong></p>
<p>通过网络获取<strong>已编码的H.264数据流</strong>进行<strong>MPEG-4</strong>处理,通过使用<code>AVSampleBufferDisplayLayer</code>解码获取图像显示到设备上。<br><img src="https://twenty-zp.gitbooks.io/-/content/C9B77B4F-5091-4C80-92DE-D84C9AB44D25.png" alt="图2.2 AVSampleBufferDisplayLayer解码显示"><br><strong>图2.2</strong></p>
<p>2.1. 将获取到的<strong>已编码的数据流</strong>进行处理成<code>CMSampleBuffer</code>.<br><img src="https://twenty-zp.gitbooks.io/-/content/DEA65059-66BE-49E3-BF53-5938CB278F36.png" alt="图2.3 处理H.264码流"><br><strong>图2.3</strong></p>
<p>由图1.1可知:解码前的图像数据结构$$CMSampleBuffer = CMTime + FormatDesc + CMBlockBuffer$$组成 因此需要从H.264的码流需要以上三个信息组合成<code>CMSampleBuffer</code>.</p>
<blockquote>
<p>H.264码流由一系列的NALU单元组成.NALU单元包含视频图像数据(或视频帧片段)和H.264的参数信息。其中视频图像信息数据是CMBlockBuffer,而H.264参数信息可以组合成FormatDesc,包括编码所用的profile，level，图像的宽和高，deblock滤波器等.具体包含<strong>第一个NALU的SPS</strong>（Sequence Parameter Set）和<strong>第二个NALU的PPS</strong>（Picture Parameter Set）。</p>
</blockquote>
<p>  <img src="https://twenty-zp.gitbooks.io/-/content/F2D6F4FA-87C1-4B41-9295-6F4E1F8E43C7.png" alt="图2.3 H.264组成结构">  <strong>图2.4</strong></p>
<pre><code>* frame的数据可以分为多个slice(片段). 
* 每个slice中的数据，在帧内预测只用到自己slice的数据， 与其他slice 数据没有依赖关系。 
* NAL 是用来将编码的数据进行大包的。 比如，每一个slice 数据可以放在NAL 包中。
* I frame 是自己独立编码，不依赖于其他frame 数据。 
* P frame 依赖 I frame 数据。 
* B frame 依赖 I frame, P frame 或其他 B frame 数据。
* H.264码流的第三个NALU是IDR(即时解码器刷新),IDR图像都是I帧，H.264引入IDR图像为了解码的同步,使错
 误不被传播，当解码器解码到IDR图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，
 开一个新的序 列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不
 会使用IDR之前的图像的数据来解码。
</code></pre><p> <strong>1.1 使用<code>CMVideoFormatDescriptionCreateFromH264ParameterSets</code>提取编码的SPS和PPS压缩转换成<code>MPEG—4</code>需要的SPS和PPS,组合成<code>CMVideoFormatDescription</code></strong><br>      <img src="https://twenty-zp.gitbooks.io/-/content/9F927C1A-288F-44DF-BB7B-9B5804C55562.png" alt="图2.1.1"></p>
<pre><code>(1)每个NALU的开始码是3或4字节头:00 00 01 或 00 00 00 01,按开始码可定位NALU;
(2)提取出SPS和PPS,通过获取到的编码流,判断开始码后的第一个byte的后5位,7代表SPS,8代表PPS.      
(3)`CMVideoFormatDescriptionCreateFromH264ParameterSets`函数构建`CMVideoFormatDescription`.
</code></pre><p>   <strong>1.2 获取CMBlockBuffer</strong><br>  <img src="https://twenty-zp.gitbooks.io/-/content/FCACB659-4B39-4497-BDF4-246499F94EAC.png" alt="图2.1.2"></p>
<pre><code>(1)通过开始码,定位到NALU;
(2)确认类型数据将开始码替换为NALU的长度信息（4 Byte）
(3)通过CMBlockBufferCreateWithMemoryBlock接口构造CMBlockBufferRef
</code></pre><p>   <strong>1.3 添加CMTime</strong></p>
<p>  <img src="https://twenty-zp.gitbooks.io/-/content/BAC15B30-4D58-4ECD-A3EF-C924F61759F4.png" alt="图2.5"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/" itemprop="url">
                  二、采集视频数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:15:08+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>苹果对于音视频的采集已经提供给我们很好的封装:AVFoundation.framework.我们可以使用AVFoundation框架来采集视频数据.<br><img src="https://twenty-zp.gitbooks.io/-/content/AVCaptureSession.svg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">@interface RTAVVideoCaputre ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;</div><div class="line">&#123;</div><div class="line">    AVCaptureVideoPreviewLayer * _preViewLayer;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">@property (nonatomic,strong)AVCaptureSession *session;</div><div class="line">@property (nonatomic,strong)RTAVVideoConfiguration *videoConfiguration;</div><div class="line">@end</div><div class="line">@implementation RTAVVideoCaputre</div><div class="line"></div><div class="line">- (instancetype)initWithVideoConfiguration:(RTAVVideoConfiguration *)configuration</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _videoConfiguration = configuration;</div><div class="line">        [self addPreVideo];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#pragma mark - Method</div><div class="line">- (void)addPreVideo</div><div class="line">&#123;</div><div class="line">    AVCaptureVideoPreviewLayer * preViewLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.session];</div><div class="line">    preViewLayer.frame = [UIScreen mainScreen].bounds;</div><div class="line">    preViewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;</div><div class="line">    </div><div class="line">    _preViewLayer = preViewLayer;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - delegate</div><div class="line"></div><div class="line">#pragma mark AVCaptureSessionDelegete</div><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class="line">&#123;</div><div class="line">    CVImageBufferRef imageBuffer  = CMSampleBufferGetImageBuffer(sampleBuffer);</div><div class="line">    if (imageBuffer != NULL) &#123;</div><div class="line">        if ([_delegate respondsToSelector:@selector(captureOutput:pixelBuffer:)]) &#123;</div><div class="line">            [_delegate captureOutput:self pixelBuffer:imageBuffer];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#pragma mark - setter &amp; getter</div><div class="line">- (AVCaptureSession *)session</div><div class="line">&#123;</div><div class="line">    if (!_session) &#123;</div><div class="line">        //4.</div><div class="line">        AVCaptureSession * session = [[AVCaptureSession alloc]init];</div><div class="line">        session.sessionPreset = _videoConfiguration.avsessionPreset;</div><div class="line">        //1.</div><div class="line">        AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">        </div><div class="line">        NSError * error = nil;</div><div class="line">        //2.</div><div class="line">        AVCaptureDeviceInput * videoInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];</div><div class="line">      </div><div class="line">        //3.</div><div class="line">        AVCaptureVideoDataOutput *  videoOutput = [[AVCaptureVideoDataOutput alloc]init];</div><div class="line">        dispatch_queue_t videoDataOutputQueue = dispatch_queue_create(&quot;VideoDataOutputQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">        [videoOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];</div><div class="line">        </div><div class="line">        [videoOutput connectionWithMediaType:AVMediaTypeVideo] ;</div><div class="line">        </div><div class="line">        videoOutput.videoSettings = @&#123;(id)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_32BGRA)&#125;;</div><div class="line">        </div><div class="line">        //设置帧率</div><div class="line">        if ([device respondsToSelector:@selector(setActiveVideoMaxFrameDuration:)] &amp;&amp; [device respondsToSelector:@selector(setActiveVideoMinFrameDuration:)]) &#123;</div><div class="line">            NSError * error ;</div><div class="line">            [device lockForConfiguration:&amp;error];</div><div class="line">            if (nil == error) &#123;</div><div class="line">#if defined (__IPHONE_7_0)</div><div class="line">                device.activeVideoMaxFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoFrameRate);</div><div class="line">                device.activeVideoMinFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoFrameRate);</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line">            [device unlockForConfiguration];</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            for (AVCaptureConnection * connection in videoOutput.connections) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">                if ([connection respondsToSelector:@selector(setVideoMinFrameDuration:)])</div><div class="line">                    connection.videoMinFrameDuration = CMTimeMake(1,  (int32_t)_videoConfiguration.videoMinFrameRate);</div><div class="line">                </div><div class="line">                if ([connection respondsToSelector:@selector(setVideoMaxFrameDuration:)])</div><div class="line">                    connection.videoMaxFrameDuration = CMTimeMake(1, (int32_t)_videoConfiguration.videoMaxFrameRate);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        //5.</div><div class="line">        if ([session canAddInput:videoInput]) &#123;</div><div class="line">            [session addInput:videoInput];</div><div class="line">        &#125;</div><div class="line">        if ([session canAddOutput:videoOutput]) &#123;</div><div class="line">            [session addOutput:videoOutput];</div><div class="line">        &#125;</div><div class="line">        _session = session;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return _session;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1.通过获取系统支持有效的设备类型–视频类型;</p>
<p>2.设置作为捕捉视频的输入设备;</p>
<p>3.设置捕捉数据的输出,通过代理方法(7)获取处理<strong>未编解码的帧数据sampleBuffer;</strong></p>
<p>4.每一个实时的捕获,全部通过一个session(会话)来开启;</p>
<p>5.将输入设备和输出设备添加到会话中;</p>
<p>6.开启会话捕获.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/shi-pin-zhi-bo-xi-lie-yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/" itemprop="url">
                  iOS视频直播系列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:12:10+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/shi-pin-zhi-bo-xi-lie-yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/shi-pin-zhi-bo-xi-lie-yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本教程为是一个系列教程.从0开始带你装逼,带你飞.(开玩笑,大家共同进步^_^).如若有什么不对请指点。</p>
<p><a href="https://www.gitbook.com/book/twenty-zp/-/details" target="_blank" rel="external">内容全地址</a></p>
<p><a href="https://github.com/twenty-zp/RealTimeAVVideo" target="_blank" rel="external">Demo地址</a></p>
<p>文章从视频和音频两部分讲起。追寻以下图录流程。<br><img src="https://twenty-zp.gitbooks.io/-/content/69ABD544-ECDA-4A8D-A4BE-250D62D896E5.png" alt="导图"></p>
<p><a href="http://blog.img421.com/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/" target="_blank" rel="external">一、音视频配置文档概念</a></p>
<p><a href="http://blog.img421.com/2016/08/05/shi-pin-zhi-bo-xi-lie-er-cai-ji-shi-pin-shu-ju/" target="_blank" rel="external">二、采集视频数据</a></p>
<p><a href="http://blog.img421.com/2016/08/05/san-shi-pin-bian-jie-ma-jie-ma-pian/" target="_blank" rel="external">三、视频编解码-解码篇</a></p>
<p><a href="http://blog.img421.com/2016/08/05/si-shi-pin-de-bian-jie-ma-bian-ma-pian/" target="_blank" rel="external">四、视频的编解码-编码篇</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/" itemprop="url">
                  一、音视频配置文档概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:08:30+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/yi-yin-shi-pin-pei-zhi-wen-dang-gai-nian/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开始中我们要了解几种影响音视频的质量的关键概念:</p>
<ol>
<li><p><strong>码流</strong>(也通常称码率、比特率),指在单位时间传输或解码的位数(数据流量),是视频中画面质量控制的最重要部分。在分辨率相同的情况下,码流越大,压缩的比例就越小,画面质量越高,视频文件的体积也就越大.码流越大,说明单位时间内采样率越大,数据流和精度也越高,所以图像画面质量越好、越清晰,但要求设备的解码能力也越强;</p>
</li>
<li><p><strong>采样率</strong>(也称为采样速度或采样频率),指每秒从连续的信号中提取并组成离散信号的采样个数,使用Hz(赫兹)来表示。 能够将模拟信号转换成数字信号时的采样频率,也就是单位时间内采样多少点。一个采样点数据有多少个比特。采集的数值越大,音视频的质量越好。</p>
</li>
<li><p><strong>比特率</strong>,指每秒传送的比特数,单位我bps(Bit Per Second),比特率越大,输送的数据也就越大,音质越好.视频中的比特率通常为码率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">比特率 =采样率 * 采用位数 *声道数.</div></pre></td></tr></table></figure>
</li>
<li><p><strong>帧速度</strong>(帧率),指每秒刷新图片的帧数(FPS),帧数越多,图像动作越流畅.</p>
</li>
<li><p><strong>分辨率</strong>,即为帧的大小.每一帧都是一副图像。一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。<br>计算输出文件大小公式：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">音频编码率（KBit为单位）/8 +视频编码率（KBit为单位）/8 *影片总长度（秒为单位）</div><div class="line">=文件大小（MB为单位）</div></pre></td></tr></table></figure>
<h5 id="由此从上述概念可知"><a href="#由此从上述概念可知" class="headerlink" title="由此从上述概念可知:"></a>由此从上述概念可知:</h5><p><em>码流</em>、<em>采样率</em>、<em>帧率</em>值越大,视频和音频的质量和清晰度越大.分辨率影响图像大小,所以分辨率越高,图像越大,分辨率越低,图像越小。</p>
<p>因此,码率一定的情况下,分辨率越高,图像越不清晰.</p>
<p>但事实情况下,硬件设备也会影响,我们不能无限制的让这些参数变大,同时，码率一定的情况下,分辨率在一定的范围内取值图像都是清晰的;同样分辨率一定,码率在一定的范围内取值也都是清晰。<br><img src="https://twenty-zp.gitbooks.io/-/content/adcaae0535cc795cb6eb0ee1b179790d.jpg" alt="网络图片"></p>
<p>以上标准参考来自网络</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/dang-nsdictionaryyu-dao-nil/" itemprop="url">
                  当NSDictionary遇到nil
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T16:15:48+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/11/dang-nsdictionaryyu-dao-nil/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/11/dang-nsdictionaryyu-dao-nil/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#问题<br>在开发中我们经常会遇到如下问题：</p>
<ul>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[1]”</li>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> setObjectForKey: object cannot be nil (key: no_nillKey)”</li>
<li>failed: caught “NSInvalidArgumentException”, “<em>*</em> setObjectForKey: key cannot be nil”</li>
</ul>
<p>由上可知,Objective-C里的<strong>NSDictionary</strong>是不支持<strong>nil</strong>作为key和value的.但是总会有一些地方我们往往会不注意的插入<strong>nil</strong>值。</p>
<p>通过我们的做法是：</p>
<ol>
<li><p>使用<strong>if</strong>判断对象是否存在:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (obj) &#123;</div><div class="line">	[dic setObject:obj forKey:@&quot;obj&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>三目运算符</strong>来判断</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[dic setObject:obj?:@&quot;&quot; forKey:@&quot;obj&quot;];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做有几个坏处：</p>
<ol>
<li>代码冗余较多；</li>
<li>如果忘了检查<strong>nil</strong>,在某些情况下就会遇到以上问题;</li>
<li>后台的API大部分是以JSON 格式传递,所以一个<strong>nil</strong>值不论是传空字符还是不传都不是很正确。</li>
</ol>
<p>因此我们希望<strong>NSDictionary</strong>用起来会遇到以下几种情况:</p>
<ol>
<li><p>插入<strong>nil</strong>时不会crash</p>
</li>
<li><p>插入<strong>nil</strong>值以后(不管是<strong>key</strong>为nil还是<strong>value</strong>为nil)对应的key-value 都不包含在<strong>NSDictionary</strong>中</p>
</li>
</ol>
<p>#设计<br>根据crash 可以看出,dictionary有三个主要的入口传入nil 对象：</p>
<ol>
<li>字面量一个dictionary的时候，会调用<strong>dictionaryWithObjects:forKeys:count:</strong></li>
<li>直接调用<strong>setObjectForKey:</strong>的时候</li>
<li>通过下标方式赋值的时候(key不能为nil)调用”<strong>setObjectForKey: key cannot be nil”</strong></li>
</ol>
<p>当使用 <strong>setObjectForKey</strong>时对象是<strong>__NSDictionaryM</strong>类,同样要定义此类。<br>因此可以通过Method Swizzing 把这几种方法替换为自己的方法,在key或value 为<strong>nil</strong>的时候,并不加入到NSDictionary中.</p>
<p>以<strong>dictionaryWithObjects:forKeys:count</strong>为例:</p>
<p>创建交换方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  NSDictionary+SafeNil.m</div><div class="line">//  当NSDictionary遇到nil</div><div class="line">//</div><div class="line">//  Created by iLogiEMAC on 16/7/11.</div><div class="line">//  Copyright © 2016年 zp. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;NSDictionary+SafeNil.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation NSObject (SafeNil)</div><div class="line"></div><div class="line">+ (BOOL)swizzing_method:(SEL)originalSelector  replaceMethod:(SEL)replaceSelector</div><div class="line">&#123;</div><div class="line">    Method original = class_getInstanceMethod(self, originalSelector);</div><div class="line">    Method replace = class_getInstanceMethod(self, replaceSelector);</div><div class="line">    if (!original || !replace) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    class_addMethod(self, originalSelector, class_getMethodImplementation(self, originalSelector), method_getTypeEncoding(original));</div><div class="line">    class_addMethod(self, replaceSelector, class_getMethodImplementation(self, replaceSelector), method_getTypeEncoding(replace));</div><div class="line">    </div><div class="line">    method_exchangeImplementations(original, replace);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)swizzingClassMethod:(SEL)originSelector replaceMethod:(SEL)replaceSelector</div><div class="line">&#123;</div><div class="line">    return [object_getClass((id)self) swizzing_method:originSelector replaceMethod:replaceSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>实现自定义的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">@implementation NSDictionary (SafeNil)</div><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        [self swizzingClassMethod:@selector(initWithObjects:forKeys:count:) replaceMethod:@selector(zpSwizzing_initWithObjects:forKeys:count:)];</div><div class="line">        [self swizzingClassMethod:@selector(dictionaryWithObjects:forKeys:count:) replaceMethod:@selector(zpSwizzingClass_dictionaryWithObjects:forKeys:count:)];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)zpSwizzing_initWithObjects:(const id  _Nonnull __unsafe_unretained *)objects forKeys:(const id&lt;NSCopying&gt;  _Nonnull __unsafe_unretained *)keys count:(NSUInteger)cnt&#123;</div><div class="line">    id safeObjects[cnt];</div><div class="line">    id safeKeys[cnt];</div><div class="line">    </div><div class="line">    NSUInteger j = 0;</div><div class="line">    for (NSUInteger i = 0; i &lt; cnt ; i++) &#123;</div><div class="line">        id key = keys[i];</div><div class="line">        id obj = objects[i];</div><div class="line">        if (!key || !obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        safeObjects[j] = obj;</div><div class="line">        safeKeys[j] = key;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    return  [self zpSwizzing_initWithObjects:safeObjects forKeys:safeKeys count:j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (instancetype)zpSwizzingClass_dictionaryWithObjects:(const id  _Nonnull __unsafe_unretained *)objects forKeys:(const id&lt;NSCopying&gt;  _Nonnull __unsafe_unretained *)keys count:(NSUInteger)cnt</div><div class="line">&#123;</div><div class="line">    id safeObjects[cnt];</div><div class="line">    id safeKeys[cnt];</div><div class="line">    </div><div class="line">    NSUInteger j = 0;</div><div class="line">    for (NSUInteger i = 0; i &lt; cnt ; i++) &#123;</div><div class="line">        id key = keys[i];</div><div class="line">        id obj = objects[i];</div><div class="line">        if (!key || !obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        safeObjects[j] = obj;</div><div class="line">        safeKeys[j] = key;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    return [self zpSwizzingClass_dictionaryWithObjects:safeObjects forKeys:safeKeys count:j];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在单元测试中测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSString * no_nillKey = @&quot;no_nillKey&quot;;</div><div class="line">NSString * nilKey = nil;</div><div class="line">NSString * no_nillValue = @&quot;no_nillValue&quot;;</div><div class="line">NSString * nilValue = nil;</div><div class="line">NSDictionary * dic = @&#123;</div><div class="line">                       no_nillKey: nilValue,</div><div class="line">                       nilKey: no_nillValue</div><div class="line">&#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,dic);</div><div class="line">     </div><div class="line">dic 输出为 &#123; &#125;</div></pre></td></tr></table></figure>
<p><a href="http://tech.glowing.com/cn/how-we-made-nsdictionary-nil-safe/" target="_blank" rel="external">参考地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/08/shi-yong-interactivepopgesturerecognizerqia-zhu-de-wen-ti-bu-shi-bugde-bug/" itemprop="url">
                  使用interactivePopGestureRecognizer卡住的问题-不是BUG的BUG
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-08T10:29:23+08:00" content="2016-06-08">
              2016-06-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/08/shi-yong-interactivepopgesturerecognizerqia-zhu-de-wen-ti-bu-shi-bugde-bug/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/08/shi-yong-interactivepopgesturerecognizerqia-zhu-de-wen-ti-bu-shi-bugde-bug/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>   记录一次小问题</p>
</blockquote>
<p>苹果在iOS7的<strong>UINavigationController</strong>中加入了一个返回手势–<strong>interactivePopGestureRecognizer</strong>,因此支持iOS7以上版本,不用自己去实现一个手势去操作.<br>在iOS开发中,对于有些单独的一个<strong>ViewController</strong>页面等控制习惯性的喜欢在<strong>viewWillAppear</strong>生命周期方法中设置,因此在设置<strong>self.navigationController的interactivePopGestureRecognizer</strong>属性禁用系统时也会这样做.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillAppear:animated];    </div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为只有此单独一个页面禁用系统的手势返回,所以要让此<strong>ViewController</strong>自己去启动<strong>interactivePopGestureRecognizer</strong>. 在<strong>viewWillDisappear</strong>方法中去实现启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试的时候,当由<strong>ViewController</strong>通过<strong>push</strong>方法导航到下一个页面,然后执行手势返回的时候会发生页面卡住,但是按住<strong>Home键</strong>到后台,然后重新回到<strong>app</strong>确实可以返回到上一页面.</p>
<p>通过操作检查,当我们开始使用手势返回的时候,在执行<strong>interactivePopGestureRecognizer</strong>手势方法<strong>action=handleNavigationTransition:</strong> 时就开始执行上一个页面的<strong>viewWillAppear</strong>方法,而因此我在<strong>viewWillAppear</strong>方法中禁用了<strong>interactivePopGestureRecognizer</strong>返回手势,因此当前页面并没有看到<strong>pop</strong>动画,但确实是返回到上一页面.由此修改内容我们可以在<strong><em>viewDidAppear</em></strong>中,当页面已经显示的时候将方法禁用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/itunes-store-xie-yi-shui-wu-he-yin-xing-ye-wu-2016zui-xin-ban/" itemprop="url">
                  iTunes Connect(协议、税务和银行业务)－2016最新版
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T00:48:42+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/02/itunes-store-xie-yi-shui-wu-he-yin-xing-ye-wu-2016zui-xin-ban/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/02/itunes-store-xie-yi-shui-wu-he-yin-xing-ye-wu-2016zui-xin-ban/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应用内购开发的前提是要填写税务等一些列内容,但是填写税务的时候出现了大的变动,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Form W-8BEN: Certificate of Foreign Status of Beneficial Owner</div><div class="line">for United States Tax Withholding and Reporting (Individuals)</div><div class="line"></div><div class="line">(Rev. February 2014)</div><div class="line"></div><div class="line">Part I: Identification of Beneficial Owner</div><div class="line">1. Name of individual that is</div><div class="line">the beneficial owner:	</div><div class="line">2. Country of citizenship:	</div><div class="line">3. Permanent Residence Address:</div><div class="line">(Do Not Use P.O. Box)	Minhangpujiangzhen, Shanghai, SHANGHAI, 210000, China</div><div class="line">4. Mailing address:</div><div class="line">(if different from above)	 Same as residence</div><div class="line">5. U.S. taxpayer identification number, if required:</div><div class="line">(see instructions)	</div><div class="line"></div><div class="line"> SSN or ITIN EIN	Do you need a US Tax ID? (please see Form W-8BEN Tips sheet). If so, click to</div><div class="line">Click to download Form SS-4</div><div class="line">6. Foreign tax identifying number, if any:</div><div class="line">(optional)	</div><div class="line">7. Reference Number(s):</div><div class="line">(see instructions)	</div><div class="line">8. Date of Birth:</div><div class="line">(MM-DD-YYYY)	</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/318204-89f6e68276764869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>现在出现了<strong>W-8BEN表格填写</strong>,自己先看了一遍了解了大概,但是这些具体的内容含义不是专业人员不是太明白,因此Google了一下,查看到了一个<a href="http://7xoj45.com1.z0.glb.clouddn.com/w-8i.pdf" target="_blank" rel="external">简体</a>和<a href="http://10.0.42.153/7xoj45.com1.z0.glb.clouddn.com/W8BEN_TW_TC_ENG.pdf" target="_blank" rel="external">繁体</a>的pdf文档说明.现向大家放出来。<br>简体:<br><img src="http://upload-images.jianshu.io/upload_images/318204-6113922149210d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简体"></p>
<p>繁体:<br><img src="http://upload-images.jianshu.io/upload_images/318204-59e05ef1a8c0d2b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="繁体"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/03/shi-yong-shui-ping-he-chui-zhi-hua-dong-de-uicollectionviewlai-zhi-zuo-nian-xing-de-xing-he-lie/" itemprop="url">
                  [译]使用水平和垂直滑动的UICollectionView来制作粘性的行和列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-03T11:52:41+08:00" content="2016-05-03">
              2016-05-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/03/shi-yong-shui-ping-he-chui-zhi-hua-dong-de-uicollectionviewlai-zhi-zuo-nian-xing-de-xing-he-lie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/03/shi-yong-shui-ping-he-chui-zhi-hua-dong-de-uicollectionviewlai-zhi-zuo-nian-xing-de-xing-he-lie/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####一个tableView可以被水平和垂直滑动吗?</p>
<blockquote>
<p>免责申明（必读！）：本博客提供的所有教程的翻译原稿均来自于互联网，仅供学习交流之用，切勿进行商业传播。同时，转载时不要移除本申明。如产生任何纠纷，均与本博客所有人、发表该翻译稿之人无任何关系。谢谢合作！</p>
</blockquote>
<p>应用程序日常开发工作的现实之一就是克服日常的挑战.<a href="http://www.brightec.co.uk/ideas/uicollectionview-using-horizontal-and-vertical-scrolling-sticky-rows-and-columns?destination=taxonomy/term/1" target="_blank" rel="external">原文</a></p>
<p>远非是我们要抱怨它。我们喜欢每一个新的障碍并且爱解决各种各样的困惑和难题为我们的客户服务。</p>
<p>我们最近的挑战就是用一个<code>tableView</code>来实现水平和垂直的滑动。条件是：当水平滑动时第一列和垂直滑动时的第一行要保持静止.</p>
<p>最后,我们需要给这个tableView包含一个巨大的数据,因此它重要性就是能够平稳的滑动。<br><img src="http://upload-images.jianshu.io/upload_images/318204-d52b7b752f79a9e0.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>##挑战<br>首先,我们简单说明下挑战–有时在开发的第一步就是要明确实际的问题是什么:</p>
<ul>
<li>创建一个水平和垂直滑动的tableView.</li>
<li>水平滑动第一列和垂直滑动第一行的粘性.</li>
<li>使用大数据的情况下,必须要保持平滑的滚动.</li>
</ul>
<p>##第一次尝试-UITableView<br>我们开始考虑在UIScrollView中包含一个<code>UITableView</code>,但经过一些尝试,我们意识到:定制它的滚动和粘性是一个棘手的任务。</p>
<p>使用UITableView来做出必要的定制工作,真的很痛苦.因此,我们决定使用可定制的UICollectionView.</p>
<p>##第二次尝试-UICollectionView<br><code>UICollectionView</code>提供了强大的定制化服务,允许你设置一个自定义的<code>UICollectionFlowLayout</code>.不幸的是,网格布局的滚动只能沿着一个轴滑动:要么是水平要么是垂直.</p>
<p>我们希望我们能嵌入一个UIScrollView的集合,允许我们能够两个方向都能滑动,因此多方考虑我们决定使用<code>UICollectionFlowLayout</code>的父类<code>UICollectionViewLayout</code>的子类。</p>
<p>##UICollectionViewLayout子类<br>以下是创建<code>collectionView</code> 的步骤:</p>
<ol>
<li>创建一个<code>UICollectionViewLayout</code>的子类<code>CustomCollectionViewLayout</code>.</li>
<li>在<code>storyboard</code>中拖动一个<code>UICollectionView</code>.我们也可以使用代码创建，这取决于你自己.</li>
<li><p>在<code>storyboard</code>中的<code>Attributes Inspector</code>设置一些属性.我们设置<code>Layout</code>为<code>Custom</code>,设置<code>Class</code>为<code>CustomCollectionViewLayout</code>.<code>Scrolling Enabled</code>为选中状态,如果我们想要每次只滑动一个方向,选中<code>Direction Lock Enabled</code>.否则,会同一时刻滑动两个方向.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/318204-c6003caab22472bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>最后,将<code>UICollectionView</code>连接到<code>UIViewController</code>.不要忘记连接<code>dataSource</code>和<code>delegate</code>.</li>
<li>在我们的<code>CollectionView</code>中,这个视图表示<code>row</code>和<code>列所在的row</code>,因此记住<code>sections</code>的索引下标和<code>item</code>的索引下标.这取决我们设置<code>collectionView flow layout</code>的方向.<br><img src="http://upload-images.jianshu.io/upload_images/318204-0eb5fb59fee1e257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ol>
<ol>
<li><p>一旦完成了设置<code>collectionView</code>的方式,我们就需要设置我们自己所要创建的<code>custom collection view layout</code>.首先,我们要设置3个管理所有数据的属性.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) NSMutableArray *itemAttributes;</div><div class="line">@property (nonatomic,strong) NSMutableArray *itemsSize;</div><div class="line">@property (nonatomic, assign) CGSize contentSize;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你要自定义<code>item</code>的大小,你需要定义以下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGSize)sizeForItemWithColumnIndex:(NSUInteger)columnIndex;</div></pre></td></tr></table></figure>
<p>我强烈推荐你计算item大小存储到<code>itemsSize</code>中,是为了每一个列只计算一次.提高性能.</p>
</li>
<li><p>写如下方法并返回<code>YES</code>,是为了调用当你每次滑动<code>CollectionView</code>的时候都能够调用<code>prepareLayout</code>方法.你必须设置这个。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds</div><div class="line">&#123;  </div><div class="line">return YES; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>你需要调用以下方法布局显示的items</p>
<pre><code>  /**
   *  CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩    形。
   *  CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新    矩形。
   *  CGRectIntegral: 返回包围源矩形的最小整数矩形。
   *  const CGRect CGRectZero: 一个原点在(0, 0)，且长宽均为     0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等    价的。
   *  const CGRect CGRectNull: 空矩形。这个会在，比如说，求两    个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。
   *  const CGRect CGRectInfinite: 无穷大矩形。
   *  CGRectDivide: 将源矩形分为两个子矩形。
   */
- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
        {
       NSMutableArray *attributes = [@[] mutableCopy];
        for (NSArray *section in self.itemAttributes) {
               [attributes addObjectsFromArray:[section filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(UICollectionViewLayoutAttributes *evaluatedObject, NSDictionary *bindings) {
           return CGRectIntersectsRect(rect, [evaluatedObject frame]);
        }]]];
      }
            return attributes;
      }
</code></pre></li>
<li><p>你需要根据<code>indexPath</code>返回<code>layout attributes</code>,如果才能返回出正确的<code>item attribute</code>.</p>
<pre><code>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
{
    return      self.itemAttributes[indexPath.section]  [indexPath.row];
}    
</code></pre></li>
<li><p>你还需要返回<code>collectionView</code>内容视图的滑动大小.</p>
<pre><code>- (CGSize)collectionViewContentSize
{
        return self.contentSize;
}
</code></pre></li>
<li><p>最后,需要设<code>prepareLayout</code>方法.我们重画<code>collectionView</code>这将要被每次调用.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)prepareLayout;</div></pre></td></tr></table></figure>
</li>
<li><p>最后,我们要确定要展示的数据,否则返回<code>void</code></p>
<pre><code>if ([self.collectionView numberOfSections] == 0) 
{
       return;
}
</code></pre></li>
<li><p>现在必须检查我们是否已经计算了<code>item</code>的attribute.在确定的情况下,我们将要使用这个attributes来粘性头部(第15步).否则,我们要每一次都计算,并且保存他们到<code>itemAttributes</code>数组中.</p>
<p>基本上,我们为了保证它们可见,是通过遍历所有的<code>items</code>然后计算<code>item</code>的<code>size</code>、<code>frame</code>和<code>zIndex</code>.</p>
<p>最后,我们使用<code>last item</code>来计算<code>contentSize</code>为了计算出content的全部高度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">// 以下代码只在prepareLayout中执行一次</div><div class="line"> self.itemAttributes = [@[] mutableCopy];</div><div class="line"> self.itemsSize = [@[] mutableCopy];</div><div class="line">	  </div><div class="line">// Tip:我们可以使用NSUInteger来代替numberOfItemsInSection</div><div class="line">// NSUInteger numberOfItems = [self.collectionView numberOfItemsInSection:section];</div><div class="line">	  </div><div class="line">//计算每一列中item 的大小</div><div class="line">if (self.itemsSize.count != NUMBEROFCOLUMNS) &#123;</div><div class="line">  [self calculateItemsSize];</div><div class="line">&#125;</div><div class="line">// 通过循环计算items</div><div class="line">  for (int section = 0; section &lt; [self.collectionView numberOfSections]; section++) &#123;</div><div class="line">  NSMutableArray *sectionAttributes = [@[] mutableCopy];</div><div class="line">  for (NSUInteger index = 0; index &lt; NUMBEROFCOLUMNS; index++) &#123;</div><div class="line">      CGSize itemSize = [self.itemsSize[index] CGSizeValue];</div><div class="line">      // 每一次都创建一个UICollectionViewLayoutAttributes,并且保存到数组中</div><div class="line">      NSIndexPath *indexPath = [NSIndexPath indexPathForItem:index inSection:section];</div><div class="line">      UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];</div><div class="line">      attributes.frame = CGRectIntegral(CGRectMake(xOffset, yOffset, itemSize.width, itemSize.height));</div><div class="line">             if (section == 0 &amp;&amp; index == 0) &#123;</div><div class="line">          attributes.zIndex = 1024; //设置(Sec0Row0)的第一项,使其能在第一列和第一行之上</div><div class="line">      &#125; else if (section == 0 || index == 0) &#123;</div><div class="line">          attributes.zIndex = 1023; //设置第一列和第一行在其余为设置的item之上</div><div class="line">      &#125;</div><div class="line">      if (section == 0) &#123;</div><div class="line">          CGRect frame = attributes.frame;</div><div class="line">          frame.origin.y = self.collectionView.contentOffset.y;</div><div class="line">          attributes.frame = frame; // 顶部(第一行)黏性</div><div class="line">      &#125;</div><div class="line">      if (index == 0) &#123;</div><div class="line">          CGRect frame = attributes.frame;</div><div class="line">          frame.origin.x = self.collectionView.contentOffset.x;</div><div class="line">          attributes.frame = frame; // 左部(第一列)黏性</div><div class="line">      &#125;</div><div class="line">      [sectionAttributes addObject:attributes];</div><div class="line">      xOffset = xOffset+itemSize.width;</div><div class="line">      column++;</div><div class="line">      // 如果最后的列,定义最终的宽度</div><div class="line">      if (column == NUMBEROFCOLUMNS) &#123;</div><div class="line">          if (xOffset &gt; contentWidth) &#123;</div><div class="line">              contentWidth = xOffset;</div><div class="line">          &#125;  </div><div class="line">          // Reset values</div><div class="line">          column = 0;</div><div class="line">          xOffset = 0;</div><div class="line">          yOffset += itemSize.height;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  [self.itemAttributes addObject:sectionAttributes];</div><div class="line">&#125;</div><div class="line"> //获取最后的一个item 来计算 content的全部高度</div><div class="line">UICollectionViewLayoutAttributes *attributes = [[self.itemAttributes lastObject] lastObject];</div><div class="line">contentHeight = attributes.frame.origin.y+attributes.frame.size.height;</div><div class="line">self.contentSize = CGSizeMake(contentWidth, contentHeight);</div></pre></td></tr></table></figure>
</li>
<li><p>事实上我们已经在之前计算过<code>items attributes</code>,我们只需要(垂直滑动的时候)通过设置<code>first row</code>的<code>y-offset</code>和(水平滑动)设置<code>first columns</code>的<code>x-offset</code>即可.</p>
<pre><code>//如果不进入以下if语句,就会执行计算方法
if (self.itemAttributes.count &gt; 0) {
     for (int section = 0; section &lt; [self.collectionView numberOfSections]; section++) {
        NSUInteger numberOfItems = [self.collectionView numberOfItemsInSection:section];
        for (NSUInteger index = 0; index &lt; numberOfItems; index++) {
             if (section != 0 &amp;&amp; index != 0)      {         //这是我们不需要黏性的内容
              continue;
           }
        UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:index inSection:section]];
        if (section == 0) { // 顶部(第一行)黏性
            CGRect frame = attributes.frame;
            frame.origin.y = self.collectionView.contentOffset.y;
            attributes.frame = frame;
        }
        if (index == 0) { // 左部(第一列)黏性
            CGRect frame = attributes.frame;
            frame.origin.x = self.collectionView.contentOffset.x;
            attributes.frame = frame;
        }
    }
}
return;
}
</code></pre></li>
</ol>
<p>如若喜欢请点赞或关注,不定期的发布文章或译文.</p>
<p><a href="https://github.com/twenty-zp/CustomCollectionViewLayout/archive/master.zip" target="_blank" rel="external">源代码下载</a></p>
<p><a href="http://blog.img421.com/2016/05/03/shi-yong-shui-ping-he-chui-zhi-hua-dong-de-uicollectionviewlai-zhi-zuo-nian-xing-de-xing-he-lie/" target="_blank" rel="external">ps: 转载注明出处</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/14/react-native-ru-men/" itemprop="url">
                  React Native 开发系列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-14T11:15:07+08:00" content="2016-04-14">
              2016-04-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/14/react-native-ru-men/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/14/react-native-ru-men/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>你只有一定要,才一定会得到.<br>                                  – 沃兹基朔德</p>
</blockquote>
<p><img src="/content/images/2016/04/React-Native.png" alt=""><br>React Native发布已经有一段时间了,发布之后只是大概的了解下作用并没有做其余的工作,前段时间公司项目被客户要求使用HTML5开发,<code>React Native</code>因为是刚出来,可能网上的资料较少以及考虑到要踩得坑比较多,所以项目考虑使用<a href="http://www.ionic.wang/" target="_blank" rel="external">Ionic中文</a>开发,虽然自己不是此项目的开发人员,但是因为要写原生iOS插件,只是简单的了解了下<a href="http://www.ionic.wang/" target="_blank" rel="external">Ionic中文</a>,在写好的HTML5项目中,调试iOS插件的情况下,因为HTML5占用手机内存比较大,有时候手机没有交互效果,要每次重新运行很多次才可以,因此想到使用<code>React Native</code>试一下看看效果怎么样.</p>
<p>以下只是显示简单的请求服务器登录和列表页面,后续工作也在进行当中:<br><img src="/content/images/2016/04/2016-04-14-11_45_48.gif" alt=""></p>
<p>###开始工作</p>
<ol>
<li><p>开发工具: <a href="https://www.sublimetext.com/3" target="_blank" rel="external">Sublimt Text</a></p>
</li>
<li><p>JavaScript教程:<a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="external">W3School-JavaScript</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">MDN-JavaScript</a>教程.</p>
</li>
<li><p>CSS样式教程:<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="external">MDN-CSS</a> 和 <a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="external">W3School-CSS</a></p>
</li>
<li><p><strong><a href="http://www.race604.com/react-native-component-lifecycle/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">了解React Native的生命周期</a></strong></p>
</li>
<li><p><a href="http://reactjs.cn/react/docs/component-api.html" target="_blank" rel="external">React.js 中文版</a></p>
</li>
<li><p><strong>请根据两篇教程走一遍,不懂的请务必<a href="https://www.google.co.jp/?gfe_rd=cr&amp;ei=_QgPV4TkNYf-8wfr17LgAg&amp;gws_rd=ssl" target="_blank" rel="external">Google</a>或其他浏览器搜索,搞明白为止.<a href="http://reactnative.cn/docs/0.23/getting-started.html" target="_blank" rel="external">React Native 中文版</a>和<a href="https://www.raywenderlich.com/126063/react-native-tutorial" target="_blank" rel="external">Raywenderlich 英文版</a></strong></p>
</li>
<li><p><strong><a href="https://github.com/facebook/css-layout" target="_blank" rel="external">FaceBook CSS-layout</a></strong></p>
</li>
<li><p><code>React Native</code>中的<code>fetch</code>方法所使用的规则同<a href="http://liubin.org/promises-book/#chapter1-what-is-promise" target="_blank" rel="external">Promise</a>.<br><a href="http://www.tuicool.com/articles/QZBJ7zJ" target="_blank" rel="external">fetch 入门</a></p>
</li>
</ol>
<p><strong>注: 如果你跟着步骤5,6,7走一遍,在不懂得情况下同时Google或者度娘,那么你即可入门</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xoj45.com1.z0.glb.clouddn.com/avtar.png"
               alt="Twenty's 时间念" />
          <p class="site-author-name" itemprop="name">Twenty's 时间念</p>
          <p class="site-description motion-element" itemprop="description">你只有一定要,才一定会得到</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Twenty's 时间念</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"twenty-zp"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
